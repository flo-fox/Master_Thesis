---
author: "Florian Fox"
date: "`r Sys.Date()`"
title: 'Master Thesis: A Causal Test of the Law of 1/n and its Mechanisms -- Analysis: RDD, Normalized Cutoff'
output:
  html_document:
    df_print: paged
    toc: true
    toc_float: true
---

# Load data and packages

```{r Packages}
time <- Sys.time()
library(tidyverse)
library(fixest)
library(rdrobust)
#library(rdmulti)
library(rddensity)
library(rdd) # For the McCrary (2008) test
library(xtable)
library(scales)
library(janitor)
source("functions.R")
```

```{r Data}
data <-
  readRDS("data/gemeinderatswahlen_alldata.rds") %>%
  mutate(
    year = as.factor(year),
    ags = as.factor(ags)
  )
```

```{r Options}
options(scipen = 20)
theme_set(theme_minimal())
```

Generating different data sets:

```{r}
# d_bivariate <- data %>%
#   select(ln_gross_expenditure_pc, total_seats, ags, year, state) %>% drop_na()
# d_bivariate_iv <- data %>%
#   select(ln_gross_expenditure_pc, total_seats, ags, year, total_seats_24_y_ago) %>% drop_na()
d_rdd_bivariate <- data %>%
  select(ln_gross_expenditure_pc, total_seats, inhabs_rel_to_cutoff, above_cutoff, inhabitants_treshold_factor, inhabitants_treshold, year, ags, election_year, state, closest, clean_disc_acc_Höhmann, clean_disc_acc_to_my_research) %>%
  drop_na(ln_gross_expenditure_pc, total_seats, inhabs_rel_to_cutoff) %>%
  # Repeat (bandwidth) window calculation for data subsets
  mutate(
    closest = base::rank(abs(inhabs_rel_to_cutoff), ties.method = "last"),
    closest = closest/max(closest),
  )

# d_controls <- data %>%
#   select(ln_gross_expenditure_pc, total_seats, ags, year, inh_tot, pop_over65, unempl_rate, total_area_ha,
#     share_working_age, kreisfreie_stadt, stadt, years_since_last_elec, state) %>%
#   drop_na()
# d_controls_iv <- data %>%
#   select(ln_gross_expenditure_pc, total_seats, ags, year, total_seats_24_y_ago, inh_tot, pop_over65,
#          unempl_rate, total_area_ha, share_working_age, kreisfreie_stadt, stadt,
#          years_since_last_elec) %>%
#   drop_na()
d_rdd <- data %>%
  select(ln_gross_expenditure_pc, total_seats, inhabs_rel_to_cutoff, above_cutoff, closest,
         inhabitants_treshold_factor, year, ags, state,
         inh_tot, pop_over65, unempl_rate, total_area_ha,
         share_working_age, kreisfreie_stadt, stadt, years_since_last_elec) %>%
  drop_na() %>%
  # Repeat (bandwidth) window calculation for data subsets
  mutate(
    closest = base::rank(abs(inhabs_rel_to_cutoff), ties.method = "last"),
    closest = closest/max(closest),
  )
d_ttest <- data %>%
  select(ln_gross_expenditure_pc, inhabs_rel_to_cutoff) %>% drop_na()
```



# Introduction

Sharp RDD mit "intention-to-treat" effect?

Treating all of the cutoffs as one requires a harmonization. This happens according to Egger and Koethenbuerger (2010):

Using the Egger and Koethenbuerger (2010) calculation steps:
$$\tilde{N_i} = ln( N_i/N_d )$$
with $N_i$ as the relevant actual population size and $N_d$ as the respective thresholds.


# t test

The most simple thing to do is a simple t test for differences.

```{r}
# 0.1 around cutoff
d_ttest2 <- d_ttest %>%
  filter(abs(inhabs_rel_to_cutoff) < 0.1) # Choose bandwidth
nrow(d_ttest2) / nrow(data) # Share of observations close to threshold
t.test(log(d_ttest2$ln_gross_expenditure_pc[d_ttest2$inhabs_rel_to_cutoff < 0]),
       log(d_ttest2$ln_gross_expenditure_pc[d_ttest2$inhabs_rel_to_cutoff >= 0]))
# 0.05 around cutoff
d_ttest2 <- d_ttest %>%
  filter(abs(inhabs_rel_to_cutoff) < 0.05) # Choose bandwidth
nrow(d_ttest2) / nrow(data) # Share of observations close to threshold
t.test(log(d_ttest2$ln_gross_expenditure_pc[d_ttest2$inhabs_rel_to_cutoff < 0]),
       log(d_ttest2$ln_gross_expenditure_pc[d_ttest2$inhabs_rel_to_cutoff >= 0]))
# 0.01 around cutoff
d_ttest2 <- d_ttest %>%
  filter(abs(inhabs_rel_to_cutoff) < 0.025) # Choose bandwidth
nrow(d_ttest2) / nrow(data) # Share of observations close to threshold
t.test(log(d_ttest2$ln_gross_expenditure_pc[d_ttest2$inhabs_rel_to_cutoff < 0]),
       log(d_ttest2$ln_gross_expenditure_pc[d_ttest2$inhabs_rel_to_cutoff >= 0]))
```

The results are not really consistent when it comes to statistical significance. The difference between both sides also heavily depends on the bandwidth chosen.
Keep in mind, however, that a t test is not exactly appropriate due to the fuzzy nature of the setting: Whether or not municipalities actually take treatment is not accounted for in this approach.

```{r}
rm(d_ttest2)
```


# Manual IV regression

This is how it is done according to ["The Effect" of Nick Huntington-Klein, chapter 20](https://theeffectbook.net/ch-RegressionDiscontinuity.html):
```{r}
df <- d_rdd_bivariate %>%
  filter(closest <= 0.1) # Choose bandwidth window -- similar to Höhmann (2017)
rdd_bivariate <- fixest::feols(ln_gross_expenditure_pc ~
                                 1  | # controls
                                 inhabitants_treshold_factor + year + ags | # fixed-effect controls
                                 # First stage regression:
                                 inhabs_rel_to_cutoff*total_seats ~ # Instrument our standard RDD...
                                 inhabs_rel_to_cutoff*above_cutoff, # ... with being above the cutoff
                               data = df)
summary(rdd_bivariate, vcov = "hetero")
summary(rdd_bivariate, vcov = "threeway", stage = 1:2)
# More tests:
#fixest::fitstat(rdd, ~ ivf1 + ivwald1 + ivf2 + ivwald2)
rm(df)
```

More simplistic version:
```{r}
df <- d_rdd_bivariate %>%
  filter(closest <= 0.1) # Choose bandwidth window -- similar to Höhmann (2017)
rdd <- fixest::feols(ln_gross_expenditure_pc ~
                     1  | # controls
                     inhabitants_treshold_factor + year + ags | # fixed-effect controls
                     # First stage regression:
                     total_seats ~ # Instrument our standard RDD...
                     above_cutoff, # ... with being above the cutoff
                     data = df)
summary(rdd, vcov = "hetero")
summary(rdd, vcov = "threeway", stage = 1:2)
# More tests:
#fixest::fitstat(rdd, ~ ivf1 + ivwald1 + ivf2 + ivwald2)
rm(df, rdd)
```

```{r, eval = FALSE}
df <- d_rdd_bivariate %>%
  filter(closest <= 0.1) # Choose bandwidth window -- similar to Höhmann (2017)
rdd <- fixest::feols(ln_gross_expenditure_pc ~
                     inhabs_rel_to_cutoff  | # controls
                     inhabitants_treshold_factor + year + ags | # fixed-effect controls
                     # First stage regression:
                     total_seats ~ # Instrument our standard RDD...
                     above_cutoff, # ... with being above the cutoff
                     data = df)
summary(rdd, vcov = "hetero")
summary(rdd, vcov = "threeway", stage = 1:2)
rm(df, rdd)
```

Include polynomials:

```{r}
df <- d_rdd_bivariate %>%
  filter(closest <= 0.1) # Choose bandwidth window -- similar to Höhmann (2017)
# Increasing the degree of polynomials
fixest::feols(ln_gross_expenditure_pc ~
                1 | # controls
                inhabitants_treshold_factor + year + ags | # fixed-effect controls
                # First stage regression:
                inhabs_rel_to_cutoff*total_seats ~ # Instrument our standard RDD...
                inhabs_rel_to_cutoff*above_cutoff, # ... with being above the cutoff
              #vcov = "threeway",
              data = df)
fixest::feols(ln_gross_expenditure_pc ~
                1  | # controls
                inhabitants_treshold_factor + year + ags | # fixed-effect controls
                # First stage regression:
                poly(inhabs_rel_to_cutoff, 2)*total_seats ~ # Instrument our standard RDD...
                poly(inhabs_rel_to_cutoff, 2)*above_cutoff, # ... with being above the cutoff
              vcov = "threeway",
              data = df)
fixest::feols(ln_gross_expenditure_pc ~
                1  | # controls
                inhabitants_treshold_factor + year + ags | # fixed-effect controls
                # First stage regression:
                poly(inhabs_rel_to_cutoff, 3)*total_seats ~ # Instrument our standard RDD...
                poly(inhabs_rel_to_cutoff, 3)*above_cutoff, # ... with being above the cutoff
              vcov = "threeway",
              data = df)
fixest::feols(ln_gross_expenditure_pc ~
                1  | # controls
                inhabitants_treshold_factor + year + ags | # fixed-effect controls
                # First stage regression:
                poly(inhabs_rel_to_cutoff, 4)*total_seats ~ # Instrument our standard RDD...
                poly(inhabs_rel_to_cutoff, 4)*above_cutoff, # ... with being above the cutoff
              vcov = "threeway",
              data = df)
fixest::feols(ln_gross_expenditure_pc ~
                1  | # controls
                inhabitants_treshold_factor + year + ags | # fixed-effect controls
                # First stage regression:
                poly(inhabs_rel_to_cutoff, 5)*total_seats ~ # Instrument our standard RDD...
                poly(inhabs_rel_to_cutoff, 5)*above_cutoff, # ... with being above the cutoff
              vcov = "threeway",
              data = df)
fixest::feols(ln_gross_expenditure_pc ~
                1  | # controls
                inhabitants_treshold_factor + year + ags | # fixed-effect controls
                # First stage regression:
                poly(inhabs_rel_to_cutoff, 6)*total_seats ~ # Instrument our standard RDD...
                poly(inhabs_rel_to_cutoff, 6)*above_cutoff, # ... with being above the cutoff
              vcov = "threeway",
              data = df)
rm(df)
```
The results do not differ in their interpretation. The coefficient of interest, `fit_total_seats`, indicates a single-digit decrease of spending at the cutoff but is never statistically significantly different from zero.

Dropping polynomials but adding controls:

```{r}
df <- d_rdd %>%
  filter(closest <= 0.1) # Choose bandwidth window -- similar to Höhmann (2017)
# Continuously adding covariates
fixest::feols(ln_gross_expenditure_pc ~
                csw0(inh_tot, pop_over65, unempl_rate, total_area_ha,
                     share_working_age, kreisfreie_stadt, stadt, years_since_last_elec) | # controls
                inhabitants_treshold_factor + year + ags | # fixed-effect controls
                # First stage regression:
                inhabs_rel_to_cutoff*total_seats ~ # Instrument our standard RDD...
                inhabs_rel_to_cutoff*above_cutoff, # ... with being above the cutoff
              vcov = "threeway",
              data = df)
# Model with covariates
rdd_w_covs <- fixest::feols(ln_gross_expenditure_pc ~
                              inh_tot + pop_over65 + unempl_rate + total_area_ha + share_working_age +
                              kreisfreie_stadt + stadt + years_since_last_elec | # controls
                              inhabitants_treshold_factor + year + ags | # fixed-effect controls
                              # First stage regression:
                              inhabs_rel_to_cutoff*total_seats ~ # Instrument our standard RDD...
                              inhabs_rel_to_cutoff*above_cutoff, # ... with being above the cutoff
                            data = df)
summary(rdd_w_covs, vcov = "threeway")
rm(df)
```
Interpretation similar to the polynomial case: decrease in the single digits but not significant.

Varying bandwidth:

```{r}
# Baseline
d_rdd_bivariate %>%
  filter(closest <= 0.1) %>% # Choose bandwidth window -- similar to Höhmann (2017)
  fixest::feols(ln_gross_expenditure_pc ~
                  1  | # controls
                  inhabitants_treshold_factor + year + ags | # fixed-effect controls
                  # First stage regression:
                  inhabs_rel_to_cutoff*total_seats ~ # Instrument our standard RDD...
                  inhabs_rel_to_cutoff*above_cutoff, # ... with being above the cutoff
                vcov = "threeway")
# Half the window
d_rdd_bivariate %>%
  filter(closest <= 0.05) %>% # Choose bandwidth window
  fixest::feols(ln_gross_expenditure_pc ~
                  1  | # controls
                  inhabitants_treshold_factor + year + ags | # fixed-effect controls
                  # First stage regression:
                  inhabs_rel_to_cutoff*total_seats ~ # Instrument our standard RDD...
                  inhabs_rel_to_cutoff*above_cutoff, # ... with being above the cutoff
                vcov = "threeway")
# Double the window size
d_rdd_bivariate %>%
  filter(closest <= 0.2) %>% # Choose bandwidth window
  fixest::feols(ln_gross_expenditure_pc ~
                  1  | # controls
                  inhabitants_treshold_factor + year + ags | # fixed-effect controls
                  # First stage regression:
                  inhabs_rel_to_cutoff*total_seats ~ # Instrument our standard RDD...
                  inhabs_rel_to_cutoff*above_cutoff, # ... with being above the cutoff
                vcov = "threeway")
# More tests:
#fixest::fitstat(rdd, ~ ivf1 + ivwald1 + ivf2 + ivwald2)
#rm(df, rdd)
```
Interpretation as before: Non-significant decrease in the single digits.

## Summary

Comparing the two main models:
```{r}
etable(rdd_bivariate, rdd_w_covs)
```

```{r}
etable(rdd_bivariate, rdd_w_covs,
       file = "tables/rdd_iv.tex",
       replace = TRUE,
       # Table settings
       drop = "!Council size",
       dict = c(total_seats = "Council size",
                ln_gross_expenditure_pc = "Ln of gross expenditure p. c."),
       signif.code = c("***"=0.001, "**"=0.01, "*"=0.05, "'"=0.10),
       headers = c("\\acs{RDD} \\acs{wo} covariates", "\\acs{RDD} \\acs{w} covariates"),
       extralines = list(
         "-^Controls" = c("No", "Yes")#,
         #"-_\\acs{SE}" = rep("by threshold, \\acs{yr} & \\acs{mcp}", 2),
         #"_^Data sample" = c(rep("All data", 3), "\\acs{BY} only")
         ),
       # LaTeX settings
       title = "Results of the \\ac{IV} \\ac{RDD}",
       label = "tab:rdd_iv",
       notes = paste("\\footnotesize{*Notes:* Results of the \\ac{IV} \\ac{RDD}, in a ten-percent window around the cutoffs.",
                     tex_control_text,
                     "Standard errors clustered at the threshold, year and municipality level in parentheses.",
                     tex_signif_text),
       style.tex = style.tex(
         fixef.suffix = " \\ac{FE}"
       )
       )
```

```{r}
rm(rdd_bivariate, rdd_w_covs)
```




# `rdrobust` package

## Bivariate RDD

Understanding the `rdrobust::rdrobust()` command:

```{r, eval=FALSE}
# to do: remove eval=FALSE
rdd <-
  rdrobust::rdrobust(
    y = d_rdd_bivariate$ln_gross_expenditure_pc,
    x = d_rdd_bivariate$inhabs_rel_to_cutoff,
    fuzzy = d_rdd_bivariate$total_seats
  )
summary(rdd)
rdd <-
  rdrobust::rdrobust(
    y = d_rdd_bivariate$ln_gross_expenditure_pc,
    x = d_rdd_bivariate$inhabs_rel_to_cutoff,
    fuzzy = d_rdd_bivariate$total_seats,
    covs = model.matrix( ~  d_rdd_bivariate$inhabitants_treshold_factor)
  )
summary(rdd)
```

Bivariate RDD without FE:
```{r, rdd_bi_wo_fe}
rdd_bi <-
  rdrobust::rdrobust(
    y = d_rdd_bivariate$ln_gross_expenditure_pc,
    x = d_rdd_bivariate$inhabs_rel_to_cutoff,
    fuzzy = d_rdd_bivariate$total_seats,
    cluster = d_rdd_bivariate$inhabitants_treshold_factor
  )
summary(rdd_bi)
```

Bivariate RDD with one-way FE:

```{r, eval=FALSE}
# to do: remove eval=FALSE
rdd <-
  rdrobust::rdrobust(
    y = d_rdd_bivariate$ln_gross_expenditure_pc,
    x = d_rdd_bivariate$inhabs_rel_to_cutoff,
    fuzzy = d_rdd_bivariate$total_seats,
    cluster = d_rdd_bivariate$inhabitants_treshold_factor,
    covs = model.matrix( ~ d_rdd_bivariate$inhabitants_treshold_factor)
  )
summary(rdd)
rdd <-
  rdrobust::rdrobust(
    y = d_rdd_bivariate$ln_gross_expenditure_pc,
    x = d_rdd_bivariate$inhabs_rel_to_cutoff,
    fuzzy = d_rdd_bivariate$total_seats,
    cluster = d_rdd_bivariate$inhabitants_treshold_factor,
    covs = model.matrix( ~ d_rdd_bivariate$year)
  )
summary(rdd)
rdd <-
  rdrobust::rdrobust(
    y = d_rdd_bivariate$ln_gross_expenditure_pc,
    x = d_rdd_bivariate$inhabs_rel_to_cutoff,
    fuzzy = d_rdd_bivariate$total_seats,
    cluster = d_rdd_bivariate$inhabitants_treshold_factor,
    covs = model.matrix( ~ d_rdd_bivariate$state)
  )
summary(rdd)
```

The threshold FE appear very important: Without them, barely any effect is visible at the first stage. But that makes sense even theoretically as the threshold level indicates on which (sharp) side of the cutoff we are.

Bivariate RDD with threeway FE:
```{r, rdd_bi_fe}
rdd <-
  rdrobust::rdrobust(
    y = d_rdd_bivariate$ln_gross_expenditure_pc,
    x = d_rdd_bivariate$inhabs_rel_to_cutoff,
    fuzzy = d_rdd_bivariate$total_seats,
    covs = model.matrix( ~ d_rdd_bivariate$inhabitants_treshold_factor + d_rdd_bivariate$year + d_rdd_bivariate$state)
  )
summary(rdd)
rdd_bi_fe <-
  rdrobust::rdrobust(
    y = d_rdd_bivariate$ln_gross_expenditure_pc,
    x = d_rdd_bivariate$inhabs_rel_to_cutoff,
    fuzzy = d_rdd_bivariate$total_seats,
    cluster = d_rdd_bivariate$inhabitants_treshold_factor,
    covs = model.matrix( ~ d_rdd_bivariate$inhabitants_treshold_factor + d_rdd_bivariate$year + d_rdd_bivariate$state)
  )
summary(rdd_bi_fe)
```

Using the `rdrobust` package, some things seem either computionally infeasible or impossible by design. Municipality FE take forever to run and are henceforth not considered (but state FE instead).

```{r, eval = FALSE}
# Takes forever to run
rdd_fe_ags <-
  rdrobust::rdrobust(
    y = d_rdd_bivariate$ln_gross_expenditure_pc,
    x = d_rdd_bivariate$inhabs_rel_to_cutoff,
    fuzzy = d_rdd_bivariate$total_seats,
    cluster = d_rdd_bivariate$inhabitants_treshold_factor,
    covs = model.matrix( ~ d_rdd_bivariate$ags)
  )
summary(rdd_fe_ags)
```

Choosing multiple cluster variables appears not possible and that is likely by design as the documentation states: "`cluster` indicates the cluster ID variable" in a singular form:
```{r, eval = FALSE}
rdd_fe <-
  rdrobust::rdrobust(
    y = d_rdd_bivariate$ln_gross_expenditure_pc,
    x = d_rdd_bivariate$inhabs_rel_to_cutoff,
    fuzzy = d_rdd_bivariate$total_seats,
    cluster = model.matrix( ~ d_rdd_bivariate$inhabitants_treshold_factor + d_rdd_bivariate$year)
  )
# or:
rdd_fe <-
  rdrobust::rdrobust(
    y = d_rdd_bivariate$ln_gross_expenditure_pc,
    x = d_rdd_bivariate$inhabs_rel_to_cutoff,
    fuzzy = d_rdd_bivariate$total_seats,
    cluster = d_rdd_bivariate$inhabitants_treshold_factor + d_rdd_bivariate$year
  )
```


## Multivariate RDD

Multivariate RDD without FE:
```{r, rdrobust_multi_fe}
rdd <-
  rdrobust::rdrobust(
    y = d_rdd$ln_gross_expenditure_pc,
    x = d_rdd$inhabs_rel_to_cutoff,
    fuzzy = d_rdd$total_seats,
    covs = d_rdd$inh_tot + d_rdd$pop_over65 + d_rdd$unempl_rate + # controls
      d_rdd$total_area_ha + d_rdd$share_working_age + # controls (cont.)
      model.matrix( ~ d_rdd$kreisfreie_stadt + d_rdd$stadt + d_rdd$years_since_last_elec) # dummy controls
  )
summary(rdd)
rdd_multi <-
  rdrobust::rdrobust(
    y = d_rdd$ln_gross_expenditure_pc,
    x = d_rdd$inhabs_rel_to_cutoff,
    fuzzy = d_rdd$total_seats,
    cluster = d_rdd$inhabitants_treshold_factor,
    covs = d_rdd$inh_tot + d_rdd$pop_over65 + d_rdd$unempl_rate + # controls
      d_rdd$total_area_ha + d_rdd$share_working_age + # controls (cont.)
      model.matrix( ~ d_rdd$kreisfreie_stadt + d_rdd$stadt + d_rdd$years_since_last_elec) # dummy controls
  )
summary(rdd_multi)
```

Multivariate threeway RDD:
```{r, rdd_multi_fe}
rdd <-
  rdrobust::rdrobust(
    y = d_rdd$ln_gross_expenditure_pc,
    x = d_rdd$inhabs_rel_to_cutoff,
    fuzzy = d_rdd$total_seats,
    covs = model.matrix( ~ d_rdd$inhabitants_treshold_factor + d_rdd$year + d_rdd$state + # FE
                           d_rdd$kreisfreie_stadt + d_rdd$stadt + d_rdd$years_since_last_elec) + # dummy controls
      d_rdd$inh_tot + d_rdd$pop_over65 + d_rdd$unempl_rate + # controls
      d_rdd$total_area_ha + d_rdd$share_working_age # controls (cont.)
  )
summary(rdd)
rdd_multi_fe <-
  rdrobust::rdrobust(
    y = d_rdd$ln_gross_expenditure_pc,
    x = d_rdd$inhabs_rel_to_cutoff,
    fuzzy = d_rdd$total_seats,
    cluster = d_rdd$inhabitants_treshold_factor,
    covs = model.matrix( ~ d_rdd$inhabitants_treshold_factor + d_rdd$year + d_rdd$state + # FE
                           d_rdd$kreisfreie_stadt + d_rdd$stadt + d_rdd$years_since_last_elec) + # dummy controls
      d_rdd$inh_tot + d_rdd$pop_over65 + d_rdd$unempl_rate + # controls
      d_rdd$total_area_ha + d_rdd$share_working_age # controls (cont.)
  )
summary(rdd_multi_fe)
```

Comparison of the four main models:
```{r, rdrobust_summary}
summary(rdd_bi)
summary(rdd_bi_fe)
summary(rdd_multi)
summary(rdd_multi_fe)
```

## Manual export to LaTeX

First stage:
```{r}
rdd_tex_export_stage1 <- tibble(
  `Dependent variable:` = c("Model", "", "Running variable", "", "", "Controls", "Threshold FE", "Year FE", "State FE"),
  `Council size` = c("RDD w/o covariates", "(1)", paste0(round(rdd_bi$tau_T[1], round_decimals), assign_stars(rdd_bi$pv_T[3])), paste0("(", round(rdd_bi$se_T[1], round_decimals), ")"), paste0("[", round(rdd_bi$ci_T[3,1], 3), ", ", round(rdd_bi$ci_T[3,2], 3), "]"), rep("No", 4)),
  `2` = c("FE RDD w/o covariates", "(2)", paste0(round(rdd_bi_fe$tau_T[1], round_decimals), assign_stars(rdd_bi_fe$pv_T[3])), paste0("(", round(rdd_bi_fe$se_T[1], round_decimals), ")"), paste0("[", round(rdd_bi_fe$ci_T[3,1], 3), ", ", round(rdd_bi_fe$ci_T[3,2], 3), "]"), "No", rep("Yes", 3)),
  `3` = c("RDD w/ covariates", "(3)", paste0(round(rdd_multi$tau_T[1], round_decimals), assign_stars(rdd_multi$pv_T[3])), paste0("(", round(rdd_multi$se_T[1], round_decimals), ")"), paste0("[", round(rdd_multi$ci_T[3,1], 3), ", ", round(rdd_multi$ci_T[3,2], 3), "]"), "Yes", rep("No", 3)),
  `4` = c("FE RDD w/ covariates", "(4)", paste0(round(rdd_multi_fe$tau_T[1], round_decimals), assign_stars(rdd_multi_fe$pv_T[3])), paste0("(", round(rdd_multi_fe$se_T[1], round_decimals), ")"), paste0("[", round(rdd_multi_fe$ci_T[3,1], 3), ", ", round(rdd_multi_fe$ci_T[3,2], 3), "]"), rep("Yes", 4))
  )
```

Second stage:
```{r}
rdd_tex_export <- tibble(
  `Dependent variable:` = c("Model", "", "Council size", "", "", "Controls", "Threshold FE", "Year FE", "State FE", "Observations", "Bandwidth", "Observations below", "Observations above"),
  `Ln of gross expenditure p. c.` = c("RDD w/o covariates", "(1)", paste0(round(rdd_bi$Estimate[1], round_decimals), assign_stars(rdd_bi$pv[3])), paste0("(", round(rdd_bi$se[1], round_decimals), ")"), paste0("[", round(rdd_bi$ci[3,1], 3), ", ", round(rdd_bi$ci[3,2], 3), "]"), rep("No", 4), sum(rdd_bi$N), round(rdd_bi$bws[1,1], round_decimals), rdd_bi$N_h[1], rdd_bi$N_h[2]),
  `2` = c("FE RDD w/o covariates", "(2)", paste0(round(rdd_bi_fe$Estimate[1], round_decimals), assign_stars(rdd_bi_fe$pv[3])), paste0("(", round(rdd_bi_fe$se[1], round_decimals), ")"), paste0("[", round(rdd_bi_fe$ci[3,1], 3), ", ", round(rdd_bi_fe$ci[3,2], 3), "]"), "No", rep("Yes", 3), sum(rdd_bi_fe$N), round(rdd_bi_fe$bws[1,1], round_decimals), rdd_bi_fe$N_h[1], rdd_bi_fe$N_h[2]),
  `3` = c("RDD w/ covariates", "(3)", paste0(round(rdd_multi$Estimate[1], round_decimals), assign_stars(rdd_multi$pv[3])), paste0("(", round(rdd_multi$se[1], round_decimals), ")"), paste0("[", round(rdd_multi$ci[3,1], 3), ", ", round(rdd_multi$ci[3,2], 3), "]"), "Yes", rep("No", 3), sum(rdd_multi$N), round(rdd_multi$bws[1,1], round_decimals), rdd_multi$N_h[1], rdd_multi$N_h[2]),
  `4` = c("FE RDD w/ covariates", "(4)", paste0(round(rdd_multi_fe$Estimate[1], round_decimals), assign_stars(rdd_multi_fe$pv[3])), paste0("(", round(rdd_multi_fe$se[1], round_decimals), ")"), paste0("[", round(rdd_multi_fe$ci[3,1], 3), ", ", round(rdd_multi_fe$ci[3,2], 3), "]"), rep("Yes", 4), sum(rdd_multi_fe$N), round(rdd_multi_fe$bws[1,1], round_decimals), rdd_multi_fe$N_h[1], rdd_multi_fe$N_h[2])
  )
```

```{r}
# First-stage export
print(
  xtable::xtable(
    rdd_tex_export_stage1,
    align = "llcccc"
    ),
  file = "tables/rdd_rdrobust_stage1.tex",
  booktabs = TRUE,
  floating = FALSE,
  hline.after = c(-1, -1, 2, 5, nrow(rdd_tex_export_stage1), nrow(rdd_tex_export_stage1)),
  include.rownames = FALSE
)
# Second-stage export
print(
  xtable::xtable(
    rdd_tex_export,
    align = "llcccc"
    ),
  file = "tables/rdd_rdrobust.tex",
  booktabs = TRUE,
  floating = FALSE,
  hline.after = c(-1, -1, 2, 5, 9, nrow(rdd_tex_export), nrow(rdd_tex_export)),
  include.rownames = FALSE
)
```

## Plots

Default plots look strange for some reason:
```{r}
rdrobust::rdplot(y = d_rdd_bivariate$ln_gross_expenditure_pc, x = d_rdd_bivariate$inhabs_rel_to_cutoff)
ggplot(data = d_rdd_bivariate) +
  geom_density(aes(inhabs_rel_to_cutoff))
ggplot(data = d_rdd_bivariate) +
  geom_point(aes(x = inhabs_rel_to_cutoff, y = ln_gross_expenditure_pc))
```

Plotting the estimated model from the previous section:
```{r}
#https://stackoverflow.com/questions/56884210/rdrobust-plotting-graphs-for-local-polynomial-estimation/57614447
rdplot <- rdrobust::rdplot(
  y = d_rdd$ln_gross_expenditure_pc,
  x = d_rdd$inhabs_rel_to_cutoff,
  binselect = "es",
  scale = 5,
  kernel = tolower(rdd_bi_fe$kernel),
  p = rdd_bi_fe$p,
  h = rdd_bi_fe$bws[1],
  covs = model.matrix( ~ d_rdd$inhabitants_treshold_factor + d_rdd$year + d_rdd$state + # FE
                         d_rdd$kreisfreie_stadt + d_rdd$stadt + d_rdd$years_since_last_elec) + # dummy controls
    d_rdd$inh_tot + d_rdd$pop_over65 + d_rdd$unempl_rate + # controls
    d_rdd$total_area_ha + d_rdd$share_working_age, # controls (cont.)
  x.lim = c(-rdd_bi_fe$bws[1], rdd_bi_fe$bws[1]),
  #title = "RD Plot - Senate Elections Data",
  x.label = "Population",
  y.label = "Ln of gross expenditure p. c.",
  ci = 95)
rdplot
```

Manual plots:

`rdd_bi_fe` model: Jump at the cutoff (`r rdd_bi_fe$beta_p_r[1] - rdd_bi_fe$beta_p_l[1]`) somehow not equivalent to jump displayed in the output (e. g. in `summary()`: `r rdd_bi_fe$coef[1]`), especially given that the latter is *positive*...
```{r}
# Following Huntington-Klein, https://theeffectbook.net/ch-RegressionDiscontinuity.html
d_rdd_bivariate %>%
  mutate(inhabs_bins = cut(
    inhabs_rel_to_cutoff,
    breaks = seq(
      -rdd_bi_fe$bws[1, 1]*2,
      rdd_bi_fe$bws[1, 2]*2,
      (rdd_bi_fe$bws[1, 1] + rdd_bi_fe$bws[1, 2]) / 20 # Must break at 0
    )
  )) %>% 
    group_by(inhabs_bins) %>%
    summarize(ln_gross_expenditure_pc = mean(ln_gross_expenditure_pc),
              inhabs_mean = mean(inhabs_rel_to_cutoff)) %>%
  # "Taking the mean of running variable lets us plot data roughly at the bin midpoints"
  ggplot() + 
  geom_point(aes(x = inhabs_mean, y = ln_gross_expenditure_pc)) +
  geom_vline(aes(xintercept = 0), linetype = "dotted") +
  geom_segment(aes(x = -rdd_bi_fe$bws[1, 1],
                   y = rdd_bi_fe$beta_p_l[1]+rdd_bi_fe$beta_p_l[2]*(-rdd_bi_fe$bws[1, 1]),
                   xend = 0, yend = rdd_bi_fe$beta_p_l[1])) +
  geom_segment(aes(x = 0,
                   yend = rdd_bi_fe$beta_p_r[1]+rdd_bi_fe$beta_p_r[2]*(rdd_bi_fe$bws[1, 1]),
                   xend = rdd_bi_fe$bws[1, 1],
                   y = rdd_bi_fe$beta_p_r[1])) +
  labs(x = "Running variable", y = "Ln of gross expenditure per capita")
```

Hence, use `rdd_bi` model:
```{r}
binned <- d_rdd_bivariate %>%
  mutate(inhabs_bins = cut(
    inhabs_rel_to_cutoff,
    breaks = seq(
      -rdd_bi$bws[1, 1]*2,
      rdd_bi$bws[1, 2]*2,
      (rdd_bi$bws[1, 1] + rdd_bi$bws[1, 2]) / 20 # Must break at 0
    )
  )) %>% 
    group_by(inhabs_bins) %>%
    summarize(ln_gross_expenditure_pc = mean(ln_gross_expenditure_pc),
              inhabs_mean = mean(inhabs_rel_to_cutoff),
              n = n()) %>%
  drop_na(inhabs_bins)
ggplot(data = binned) + 
  geom_point(aes(x = inhabs_mean, y = ln_gross_expenditure_pc, size = n)) +
  scale_size_continuous(range = c(1, 2)) + # Reduced overall point size
  geom_vline(aes(xintercept = 0), linetype = "dotted") +
  geom_segment(aes(x = -rdd_bi$bws[1, 1],
                   y = rdd_bi$beta_p_l[1]+rdd_bi$beta_p_l[2]*(-rdd_bi$bws[1, 1]),
                   xend = 0, yend = rdd_bi$beta_p_l[1])) +
  geom_segment(aes(x = 0,
                   yend = rdd_bi$beta_p_r[1]+rdd_bi$beta_p_r[2]*(rdd_bi$bws[1, 1]),
                   xend = rdd_bi$bws[1, 1],
                   y = rdd_bi$beta_p_r[1])) +
  labs(x = "Running variable", y = "Ln of gross expenditure per capita")
# to do in ggplot: add big mark to ggplot legend
summary(binned$n)
sum(binned$n)
#rm(binned)
ggsave(filename = "plots/rdd_plot.pdf", width = 6, height = 6*9/16)
```




## Robustness Checks

The RDD FE model without covariates will be regarded as the baseline model. Hence, write a wrapper function to ease the use of the model:

```{r, robustness_function}
rdrobust_fe_model <- function(cc = NULL, pp = NULL, qq = NULL, hh = NULL, bb = NULL, kkernel = "tri", bbwselect = "mserd", vvce = "nn") {
  rdrobust::rdrobust(
    y = d_rdd_bivariate$ln_gross_expenditure_pc,
    x = d_rdd_bivariate$inhabs_rel_to_cutoff,
    c = cc,
    fuzzy = d_rdd_bivariate$total_seats,
    cluster = d_rdd_bivariate$inhabitants_treshold_factor,
    covs = model.matrix( ~ d_rdd_bivariate$inhabitants_treshold_factor + d_rdd_bivariate$year + d_rdd_bivariate$state),
    # set parameters to run for robustness tests; set them to rdrobust defaults
    p = pp,
    q = qq,
    h = hh,
    b = bb,
    kernel = kkernel,
    bwselect = bbwselect,
    vce = vvce
  )
}
```
```{r, eval=FALSE}
# to do: remove eval=FALSE
rdd <- rdrobust_fe_model()
summary(rdd) # equal to rdd_bi_fe model
```


### Different RDD specifications

Vary p, the local polynomial. Conclusions remain. On the first stage, council size jumps by a value somewhat larger than 1 at the threshold (highly statistically significant). The second stage, however, remains insignificant, with some p values around 0.2, the others are (in part way) larger. The coefficient is always slightly positive.
```{r, eval=FALSE}
# to do: remove eval=FALSE
rdd_vary_p_df <-
  tibble(polynomial = "", point_estimate = "", se = "", se_robust = "",
         ci_lower = "", ci_upper = "", p = "", bw = "", obs_below = "", obs_above = "") %>%
  mutate(across(everything(), as.numeric))
for (vary_p in 0:6) {
  print(paste("polynomial of degree", vary_p))
  rdd <- rdrobust_fe_model(pp = vary_p)
  summary(rdd)
  rdd_vary_p_df <- rdd_vary_p_df %>%
    dplyr::add_row(
      polynomial = vary_p,
      point_estimate = rdd$coef[1],
      se = rdd$se[1],
      se_robust = rdd$se[3],
      ci_lower = rdd$ci[3,1],
      ci_upper = rdd$ci[3,2],
      p = rdd$pv[3],
      bw = rdd$bws[1,1],
      obs_below = rdd$N_h[1],
      obs_above = rdd$N_h[2]
  )
}
rdd_vary_p_df <- rdd_vary_p_df %>% drop_na()
save(rdd_vary_p_df, file = "tables_robustness_checks/rdd_vary_p_df.Rdata")
```
```{r}
load(file = "tables_robustness_checks/rdd_vary_p_df.Rdata")
rdd_vary_p_df
```

Vary q, the "local-polynomial used to construct the bias correction". Conclusions similar to varying p: Highly significant first stage across all `q`s, non-significant second stage (p values as low as 0.2) and positive around 1%.
```{r, rdd_vary_q, eval=FALSE}
# to do: remove eval=FALSE
rdd_vary_q_df <-
  tibble(polynomial = "", point_estimate = "", se = "", se_robust = "",
         ci_lower = "", ci_upper = "", p = "", bw = "", obs_below = "", obs_above = "") %>%
  mutate(across(everything(), as.numeric))
for (vary_q in 2:6) {
  print(paste("polynomial of degree", vary_q))
  rdd <- rdrobust_fe_model(qq = vary_q)
  summary(rdd)
  rdd_vary_q_df <- rdd_vary_q_df %>%
    dplyr::add_row(
      polynomial = vary_q,
      point_estimate = rdd$coef[1],
      se = rdd$se[1],
      se_robust = rdd$se[3],
      ci_lower = rdd$ci[3,1],
      ci_upper = rdd$ci[3,2],
      p = rdd$pv[3],
      bw = rdd$bws[1,1],
      obs_below = rdd$N_h[1],
      obs_above = rdd$N_h[2]
  )
}
rdd_vary_q_df <- rdd_vary_q_df %>% drop_na()
save(rdd_vary_q_df, file = "tables_robustness_checks/rdd_vary_q_df.Rdata")
```
```{r}
load(file = "tables_robustness_checks/rdd_vary_q_df.Rdata")
rdd_vary_q_df
```

Vary kernel: No large differences between kernels.
```{r, rdd_vary_kernel, eval=FALSE}
# to do: remove eval=FALSE
rdd_vary_kernel_df <-
  tibble(kernel = "", point_estimate = "", se = "", se_robust = "",
         ci_lower = "", ci_upper = "", p = "", bw = "", obs_below = "", obs_above = "") %>%
  mutate(across(2:last_col(), as.numeric))
for (vary_kernel in c("tri", "epa", "uni")) {
  print(paste("kernel:", vary_kernel))
  rdd <- rdrobust_fe_model(kkernel = vary_kernel)
  summary(rdd)
  rdd_vary_kernel_df <- rdd_vary_kernel_df %>%
    dplyr::add_row(
      kernel = vary_kernel,
      point_estimate = rdd$coef[1],
      se = rdd$se[1],
      se_robust = rdd$se[3],
      ci_lower = rdd$ci[3,1],
      ci_upper = rdd$ci[3,2],
      p = rdd$pv[3],
      bw = rdd$bws[1,1],
      obs_below = rdd$N_h[1],
      obs_above = rdd$N_h[2]
  )
}
rdd_vary_kernel_df <- rdd_vary_kernel_df %>% drop_na()
save(rdd_vary_kernel_df, file = "tables_robustness_checks/rdd_vary_kernel_df.Rdata")
```
```{r}
load(file = "tables_robustness_checks/rdd_vary_kernel_df.Rdata")
rdd_vary_kernel_df
```

Vary variance-covariance matrix: The `hc` vce appear extremely similar. Conclusions, however, are not altered.
```{r, rdd_vary_vcov, eval=FALSE}
# to do: remove eval=FALSE
rdd_vary_vcov_df <-
  tibble(vcov = "", point_estimate = "", se = "", se_robust = "",
         ci_lower = "", ci_upper = "", p = "", bw = "", obs_below = "", obs_above = "") %>%
  mutate(across(2:last_col(), as.numeric))
for (vary_vcov in c("nn", "hc0", "hc1", "hc2", "hc3")) {
  print(paste("vce:", vary_vcov))
  rdd <- rdrobust_fe_model(vvce = vary_vcov)
  summary(rdd)
  rdd_vary_vcov_df <- rdd_vary_vcov_df %>%
    dplyr::add_row(
      vcov = vary_vcov,
      point_estimate = rdd$coef[1],
      se = rdd$se[1],
      se_robust = rdd$se[3],
      ci_lower = rdd$ci[3,1],
      ci_upper = rdd$ci[3,2],
      p = rdd$pv[3],
      bw = rdd$bws[1,1],
      obs_below = rdd$N_h[1],
      obs_above = rdd$N_h[2]
  )
}
rdd_vary_vcov_df <- rdd_vary_vcov_df %>% drop_na()
save(rdd_vary_vcov_df, file = "tables_robustness_checks/rdd_vary_vcov_df.Rdata")
```
```{r}
load(file = "tables_robustness_checks/rdd_vary_vcov_df.Rdata")
rdd_vary_vcov_df
```

### Sensitivity analysis

Vary the bandwidths `h` and `b`, manually set those instead of using a data-driven algorithm. If `h` is manually set to a certain value, the function sets `b` to the very same value. However, since the two are typically not in the same ballpark when calculated automatically (i. e. in a data-driven way), I will run the two loops separately with different values.
Conclusion: In these cases, varying the parameters does matter for the result (this is not the case with `p` and `q`). The larger the bandwidth, the larger the first-stage coefficient. In addition, the significance level of the second stage coefficient increases (the p value decreases) in the bandwidth. The value of the coefficient of interest is steady at a bit more than 1%. Note, however, that the last models include more than half of the sample size in the calculation, potentially invalidating the research design.
```{r, rdd_bw_manual, eval=FALSE}
# to do: remove eval=FALSE
rdd_vary_h_df <-
  tibble(h = "", point_estimate = "", se = "", se_robust = "",
         ci_lower = "", ci_upper = "", p = "", bw = "", obs_below = "", obs_above = "") %>%
  mutate(across(everything(), as.numeric))
for (vary_h in seq(0.02, 0.2, 0.03)) {
  print(paste("h = ", vary_h))
  rdd <- rdrobust_fe_model(hh = vary_h)
  summary(rdd)
  rdd_vary_h_df <- rdd_vary_h_df %>%
    dplyr::add_row(
      h = vary_h,
      point_estimate = rdd$coef[1],
      se = rdd$se[1],
      se_robust = rdd$se[3],
      ci_lower = rdd$ci[3,1],
      ci_upper = rdd$ci[3,2],
      p = rdd$pv[3],
      bw = rdd$bws[1,1],
      obs_below = rdd$N_h[1],
      obs_above = rdd$N_h[2]
  )
}
rdd_vary_h_df <- rdd_vary_h_df %>% drop_na()
save(rdd_vary_h_df, file = "tables_robustness_checks/rdd_vary_h_df.Rdata")
```
```{r}
load(file = "tables_robustness_checks/rdd_vary_h_df.Rdata")
rdd_vary_h_df
```

Apparently, the bandwidth `b` cannot be set manually. Perhaps change `rho` parameter or set `b` manually and `b` via the `bwselect()` function.
```{r, eval=FALSE}
for (vary_b in seq(0.15, 0.45, 0.075)) {
  print(paste("RDD with bandwidth b =", vary_b))
  rdd <- rdrobust_fe_model(bb = vary_b)
  summary(rdd)
}
```

Window bandwidth selection (similar to Höhmann, 2017; i. e. do not use automatic bandwidth selection algorithm but all observations within the window chosen). For large window values (>0.05), the conclusions drawn remain unchanged. For window values <=0.05, however, the coefficients for council size at the second stage are significant. Nevertheless, the sign switches: For low window values, there is a negative effect (-6% and -3%, respectively), for higher window cutoffs, there is a weakly positive effect. Regarding the sample size, note that even the smallest window yields a sample size of more than 1000 observations.
```{r, rdd_window, eval=FALSE}
# to do: remove eval=FALSE
rdd_vary_window <-
  tibble(window = "", point_estimate = "", se = "", se_robust = "",
         ci_lower = "", ci_upper = "", p = "", bw = "", obs_below = "", obs_above = "") %>%
  mutate(across(everything(), as.numeric))
for (vary_window in seq(0.01, 0.25, 0.01)) {
  print(paste("RDD with window: ", vary_window))
  df <- d_rdd_bivariate %>%
    filter(closest <= vary_window)
  str(vary_window)
  rdd <-
    rdrobust::rdrobust(
      y = df$ln_gross_expenditure_pc,
      x = df$inhabs_rel_to_cutoff,
      fuzzy = df$total_seats,
      cluster = df$inhabitants_treshold_factor,
      covs = model.matrix( ~ df$inhabitants_treshold_factor + df$year + df$state),
      h = 10 # 10 is larger than any absolute value of the running variable => use all observations
  )
  summary(rdd)
  rdd_vary_window <- rdd_vary_window %>%
    dplyr::add_row(
      window = vary_window,
      point_estimate = rdd$coef[1],
      se = rdd$se[1],
      se_robust = rdd$se[3],
      ci_lower = rdd$ci[3,1],
      ci_upper = rdd$ci[3,2],
      p = rdd$pv[3],
      bw = rdd$bws[1,1],
      obs_below = rdd$N_h[1],
      obs_above = rdd$N_h[2]
  )
}
rdd_vary_window <- rdd_vary_window %>% drop_na()
save(rdd_vary_window, file = "tables_robustness_checks/rdd_vary_window.Rdata")
```
```{r}
load(file = "tables_robustness_checks/rdd_vary_window.Rdata")
rdd_vary_window
```
Plot windows. Coefficients and CIs need not overlap because standard coefficients are paired with robust-corrected CIs.

```{r, rdd_window_plot}
ggplot2::ggplot(data = rdd_vary_window, aes(x = window, y = point_estimate)) +
  geom_point(size = 1.5, color = ifelse(rdd_vary_window$p <= 0.05, 2, 1)) +
  geom_errorbar(aes(ymin = ci_lower, ymax = ci_upper),
                color = ifelse(rdd_vary_window$p <= 0.05, 2, 1),
                width = 0.005) +
  geom_hline(aes(yintercept = 0), linetype = "dotted") +
  scale_x_continuous(labels = scales::percent) +
  scale_y_continuous(labels = scales::percent) +
  labs(x = "Window around the threshold", y = "Increase in spending at the threshold")
ggsave(filename = "plots/rdrobust_bw_window.pdf", width = 6, height = 6*9/16)
```


Different `rdbwselect` options: Most bandwidth selection algorithms yield similar results to the default one. One or two, however, gain statistical significance for the regressor of interest by virtue of a larger bandwidth.
```{r, eval=FALSE}
# to do: remove eval=FALSE
rdd_vary_bwselect <-
  tibble(bw_sel_algo = "", point_estimate = "", se = "", se_robust = "",
         ci_lower = "", ci_upper = "", p = "", bw = "", obs_below = "", obs_above = "") %>%
  mutate(across(2:last_col(), as.numeric))
for (vary_bwselect in c("mserd", "msetwo", "msesum", "msecomb1", "msecomb2", "cerrd", "certwo", "cersum", "cercomb1", "cercomb2")) {
  print(paste("Bandwidth selection algorithm:", vary_bwselect))
  rdd <- rdrobust_fe_model(bbwselect = vary_bwselect)
  #summary(rdd)
  rdd_vary_bwselect <- rdd_vary_bwselect %>%
    dplyr::add_row(
      bw_sel_algo = vary_bwselect,
      point_estimate = rdd$coef[1],
      se = rdd$se[1],
      se_robust = rdd$se[3],
      ci_lower = rdd$ci[3,1],
      ci_upper = rdd$ci[3,2],
      p = rdd$pv[3],
      bw = rdd$bws[1,1],
      obs_below = rdd$N_h[1],
      obs_above = rdd$N_h[2]
  )
}
rdd_vary_bwselect <- rdd_vary_bwselect %>% drop_na()
save(rdd_vary_bwselect, file = "tables_robustness_checks/rdd_vary_bwselect")
```
```{r}
load(file = "tables_robustness_checks/rdd_vary_bwselect")
rdd_vary_bwselect
```

Plot bandwidth selection algorithms. Coefficients and CIs need not overlap because standard coefficients are paired with robust-corrected CIs.
Note: In general may be a good idea, but hard to explain all bandwidth selectors in the paper just for the purpose of this plot...
```{r, rdd_window_plot2, eval=FALSE}
# to do: remove eval=FALSE
ggplot2::ggplot(data = rdd_vary_bwselect, aes(x = bw_sel_algo, y = point_estimate)) +
  geom_point(size = 1.5, color = ifelse(rdd_vary_bwselect$p <= 0.05, 2, 1)) +
  geom_errorbar(aes(ymin = ci_lower, ymax = ci_upper),
                color = ifelse(rdd_vary_bwselect$p <= 0.05, 2, 1),
                width = 0.5) +
  geom_hline(aes(yintercept = 0), linetype = "dotted") +
  scale_y_continuous(labels = scales::percent) +
  labs(x = "Bandwidth selection procedure", y = "Increase in spending at the threshold")
```

```{r}
rm(rdd)
```


### Dropping confounded thresholds

Dropping confounded thresholds as determined by my own legal research: The conclusions are quite similar for both "Höhmann's" and "my" thresholds -- the effect of council size is small and positive (in the really small single-digits) but nonsignificant for both counfounded as well as nonconfounded thresholds.

Note: (to do) maybe you could also solve this by interacting `clean_dis_acc_to_my_research`.

```{r, rdd_confounded_th_my}
# Effect for confounded thresholds
df <- d_rdd_bivariate %>%
    filter(clean_disc_acc_to_my_research == 0)
rdd <-
  rdrobust::rdrobust(
    y = df$ln_gross_expenditure_pc,
    x = df$inhabs_rel_to_cutoff,
    fuzzy = df$total_seats,
    cluster = df$inhabitants_treshold_factor,
    covs = model.matrix(~ df$inhabitants_treshold_factor + df$year + df$state)
  )
summary(rdd)
# Effect for noncounfounded thresholds
df <- d_rdd_bivariate %>%
    filter(clean_disc_acc_to_my_research == 1)
rdd <-
  rdrobust::rdrobust(
    y = df$ln_gross_expenditure_pc,
    x = df$inhabs_rel_to_cutoff,
    fuzzy = df$total_seats,
    cluster = df$inhabitants_treshold_factor,
    covs = model.matrix(~ df$inhabitants_treshold_factor + df$year + df$state)
  )
summary(rdd)
```

Dropping confounded thresholds as determined by Höhmann (2017):

```{r rdd_confounded_th_hohmann}
# Effect for confounded thresholds
df <- d_rdd_bivariate %>%
    filter(clean_disc_acc_Höhmann == 0)
rdd <-
  rdrobust::rdrobust(
    y = df$ln_gross_expenditure_pc,
    x = df$inhabs_rel_to_cutoff,
    fuzzy = df$total_seats,
    cluster = df$inhabitants_treshold_factor,
    covs = model.matrix(~ df$inhabitants_treshold_factor + df$year + df$state)
  )
summary(rdd)
# Effect for noncounfounded thresholds
df <- d_rdd_bivariate %>%
    filter(clean_disc_acc_Höhmann == 1)
rdd <-
  rdrobust::rdrobust(
    y = df$ln_gross_expenditure_pc,
    x = df$inhabs_rel_to_cutoff,
    fuzzy = df$total_seats,
    cluster = df$inhabitants_treshold_factor,
    covs = model.matrix(~ df$inhabitants_treshold_factor + df$year + df$state)
  )
summary(rdd)
```


### Placebo thresholds

First attempt

```{r, rdrobust_place1, eval=FALSE}
# to do: remove eval=FALSE
rdd_placebo <-
  tibble(placebo_c = "", point_estimate = "", se = "", se_robust = "",
         ci_lower = "", ci_upper = "", p = "", bw = "", obs_below = "", obs_above = "") %>%
  mutate(across(everything(), as.numeric))
vector <- seq(from = -(2+2/3), to = 2/3, by = 1/6) # Choose vector of arbitrary placebo cutoffs
#vector <- vector[!vector %in% (-2-1/3)]
vector <- vector[-c(3, 21)] # Drop cutoffs that yield errors
for (i in vector) {
  print(paste("Cutoff at:", i))
  rdd <- rdrobust_fe_model(cc = i)
  #summary(rdd)
  rdd_placebo <- rdd_placebo %>%
    dplyr::add_row(
      placebo_c = i,
      point_estimate = rdd$coef[1],
      se = rdd$se[1],
      se_robust = rdd$se[3],
      ci_lower = rdd$ci[3,1],
      ci_upper = rdd$ci[3,2],
      p = rdd$pv[3],
      bw = rdd$bws[1,1],
      obs_below = rdd$N_h[1],
      obs_above = rdd$N_h[2]
  )
}
rdd_placebo <- rdd_placebo %>% drop_na()
rm(vector)
save(rdd_placebo, file = "tables_robustness_checks/rdd_placebo_1.Rdata")
```
```{r}
load(file = "tables_robustness_checks/rdd_placebo_1.Rdata")
rdd_placebo
```
Visualization of placebo cutoffs:
```{r, rdrobust_placebo_viz1, eval=FALSE}
# to do: remove eval=FALSE
df <- rdd_placebo %>%
  #tidyr::drop_na() %>%
  filter(abs(ci_upper) < 100 | abs(ci_lower) < 100) %>%
  mutate(effective_n = trimws(format(sum(obs_below, obs_above), big.mark = ",") ) ) # add big mark
ggplot2::ggplot(df) +
  geom_point(aes(x = placebo_c, y = point_estimate), size = 1.5, colour = ifelse(df$p <= 0.05, 2, 1)) +
  geom_errorbar(aes(x = placebo_c, ymin = ci_lower, ymax = ci_upper),
                colour = ifelse(df$p <= 0.05, 2, 1),
                linetype = ifelse(df$p <= 0.05, 2, 1)) +
  geom_text(aes(x = placebo_c, y = ci_lower, label = effective_n),
            colour = ifelse(df$p <= 0.05, 2, 1), vjust = 1, size = 2.3, check_overlap = TRUE) +
  geom_hline(aes(yintercept = 0), linetype = "dotted") +
  geom_vline(aes(xintercept = 0), linetype = "dotted") +
  scale_y_continuous(labels = scales::percent) +
  labs(x = "Cutoff of the running variable", y = "Increase in spending at the threshold")
ggsave(filename = "plots/rdrobust_placebo_wide.pdf", width = 6, height = 6*9/16)
rm(df)
```

Second attempt: Regular cutoffs within the inter-quartile range.

```{r, rdrobust_place2, eval=FALSE}
# to do: remove eval=FALSE
rdd_placebo <-
  tibble(placebo_c = "", point_estimate = "", se = "", se_robust = "",
         ci_lower = "", ci_upper = "", p = "", bw = "", obs_below = "", obs_above = "") %>%
  mutate(across(everything(), as.numeric))
vector <- seq(from = (-0.15), to = (0.18), by = 0.03) # Choose vector of arbitrary placebo cutoffs
for (i in vector) {
  print(paste("Cutoff at:", i))
  rdd <- rdrobust_fe_model(cc = i)
  #summary(rdd)
  rdd_placebo <- rdd_placebo %>%
    dplyr::add_row(
      placebo_c = i,
      point_estimate = rdd$coef[1],
      se = rdd$se[1],
      se_robust = rdd$se[3],
      ci_lower = rdd$ci[3,1],
      ci_upper = rdd$ci[3,2],
      p = rdd$pv[3],
      bw = rdd$bws[1,1],
      obs_below = rdd$N_h[1],
      obs_above = rdd$N_h[2]
  )
}
rdd_placebo <- rdd_placebo %>% drop_na()
rm(vector)
save(rdd_placebo, file = "tables_robustness_checks/rdd_placebo_2.Rdata")
```
```{r}
load(file = "tables_robustness_checks/rdd_placebo_2.Rdata")
rdd_placebo
```
Visualization of placebo cutoffs:
```{r, rdrobust_placebo_viz2, eval=FALSE}
# to do: remove eval=FALSE
df <- rdd_placebo %>%
  #tidyr::drop_na() %>%
  #filter(abs(ci_upper) < 100 | abs(ci_lower) < 100) %>%
  mutate(effective_n = paste0("n=", trimws(format(sum(obs_below, obs_above), big.mark = ",") ) ) ) # add big mark
ggplot2::ggplot(df) +
  geom_point(aes(x = placebo_c, y = point_estimate), size = 1.5, colour = ifelse(df$p <= 0.05, 2, 1)) +
  geom_errorbar(aes(x = placebo_c, ymin = ci_lower, ymax = ci_upper),
                colour = ifelse(df$p <= 0.05, 2, 1),
                linetype = ifelse(df$p <= 0.05, 2, 1)) +
  geom_text(aes(x = placebo_c, y = ci_lower, label = effective_n),
            colour = ifelse(df$p <= 0.05, 2, 1), vjust = 1) +
  geom_hline(aes(yintercept = 0), linetype = "dotted") +
  geom_vline(aes(xintercept = 0), linetype = "dotted") +
  scale_y_continuous(labels = scales::percent) +
  labs(x = "Cutoff of the running variable", y = "Increase in spending at the threshold")
ggsave(filename = "plots/rdrobust_placebo1.pdf", width = 6, height = 6*9/16)
rm(df)
```

Third attempt: Random cutoffs within the inter-quartile range.

```{r, rdrobust_place3, eval=FALSE}
# to do: remove eval=FALSE
rdd_placebo <-
  tibble(placebo_c = "", point_estimate = "", se = "", se_robust = "",
         ci_lower = "", ci_upper = "", p = "", bw = "", obs_below = "", obs_above = "") %>%
  mutate(across(everything(), as.numeric))
set.seed(1234)
vector <- runif(n = 10, min = -0.15, max = 0.18) # Choose vector of random placebo cutoffs
for (i in vector) {
  print(paste("Cutoff at:", i))
  rdd <- rdrobust_fe_model(cc = i)
  #summary(rdd)
  rdd_placebo <- rdd_placebo %>%
    dplyr::add_row(
      placebo_c = i,
      point_estimate = rdd$coef[1],
      se = rdd$se[1],
      se_robust = rdd$se[3],
      ci_lower = rdd$ci[3,1],
      ci_upper = rdd$ci[3,2],
      p = rdd$pv[3],
      bw = rdd$bws[1,1],
      obs_below = rdd$N_h[1],
      obs_above = rdd$N_h[2]
  )
}
rdd_placebo <- rdd_placebo %>% drop_na() %>% arrange(placebo_c)
rm(vector)
save(rdd_placebo, file = "tables_robustness_checks/rdd_placebo_3.Rdata")
```
```{r}
load(file = "tables_robustness_checks/rdd_placebo_3.Rdata")
rdd_placebo
```
Visualization of placebo cutoffs:
```{r, rdrobust_placebo_viz3, eval=FALSE}
# to do: remove eval=FALSE
df <- rdd_placebo %>%
  #tidyr::drop_na() %>%
  #filter(abs(ci_upper) < 100 | abs(ci_lower) < 100) %>%
  mutate(effective_n = paste0("n=", trimws(format(sum(obs_below, obs_above), big.mark = ",") ) ) ) # add big mark
ggplot2::ggplot(df) +
  geom_point(aes(x = placebo_c, y = point_estimate), size = 1.5, colour = ifelse(df$p <= 0.05, 2, 1)) +
  geom_errorbar(aes(x = placebo_c, ymin = ci_lower, ymax = ci_upper),
                colour = ifelse(df$p <= 0.05, 2, 1),
                linetype = ifelse(df$p <= 0.05, 2, 1)) +
  geom_text(aes(x = placebo_c, y = ci_lower, label = effective_n),
            colour = ifelse(df$p <= 0.05, 2, 1), vjust = 1) +
  geom_hline(aes(yintercept = 0), linetype = "dotted") +
  geom_vline(aes(xintercept = 0), linetype = "dotted") +
  scale_y_continuous(labels = scales::percent) +
  labs(x = "Cutoff of the running variable", y = "Increase in spending at the threshold")
ggsave(filename = "plots/rdrobust_placebo2.pdf", width = 6, height = 6*9/16)
rm(df)
```


### Donut-hole RDD


### Separate years/states

**This section should be sorted into heterogeneity**

For each year: Not much variation in the results here (as expected)
```{r}
all_years <- d_rdd_bivariate %>% distinct(year) %>% pull()
for (i in all_years) {
  print(paste("year:", i))
  df <- d_rdd_bivariate %>%
    filter(year == i)
  rdd <-
    rdrobust::rdrobust(
      y = df$ln_gross_expenditure_pc,
      x = df$inhabs_rel_to_cutoff,
      fuzzy = df$total_seats,
      cluster = df$inhabitants_treshold_factor,
      covs = model.matrix( ~ df$inhabitants_treshold_factor + df$state) # Dropping year FE, obviously
  )
  summary(rdd)
}
```
For each state:
```{r}
# to do: remove eval = F
all_states <- d_rdd_bivariate %>% distinct(state) %>% filter(state != 15) %>% pull() # issues with 15...
for (i in all_states) {
  print(paste("state:", i))
  df <- d_rdd_bivariate %>%
    filter(state == i)
  rdd <-
    rdrobust::rdrobust(
      y = df$ln_gross_expenditure_pc,
      x = df$inhabs_rel_to_cutoff,
      fuzzy = df$total_seats,
      cluster = df$inhabitants_treshold_factor,
      covs = model.matrix( ~ df$inhabitants_treshold_factor + df$year) # Dropping state FE, obviously
  )
  summary(rdd)
}
```


```{r}
rm(all_years, all_states, rdd)
```


### Mass points

Investigating mass points: to do

```{r}
sum(!is.na(data$inhabs_rel_to_cutoff)) # Number of valid observations of running variable
length(unique(data$inhabs_rel_to_cutoff)) # Number of unique values of running variable
sum(!is.na(data$inhabs_rel_to_cutoff)) / length(unique(data$inhabs_rel_to_cutoff)) # 18 observations per value
```

Lee and Card 2008 procedure: Clustering at the respective dicrete values of the running variable

--> RDhonest???




# Concluding Remarks

For references, see the paper.

```{r}
Sys.time() - time
```
