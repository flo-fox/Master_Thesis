---
author: "Florian Fox"
date: "`r Sys.Date()`"
title: 'Master Thesis: A Causal Test of the Law of 1/n and its Mechanisms -- Analysis: RDD, Normalized Cutoff'
output:
  html_document:
    df_print: paged
    toc: true
    toc_float: true
---

# Load data and packages

```{r Packages}
time <- Sys.time()
library(tidyverse)
library(fixest)
library(rdrobust)
#library(rdmulti)
library(rddensity)
library(rdd) # For the McCrary (2008) test
library(xtable)
library(scales)
library(janitor)
```

```{r Data}
data <-
  readRDS("data/gemeinderatswahlen_alldata.rds") %>%
  mutate(
    year = as.factor(year),
    ags = as.factor(ags)
  )
```

```{r Options}
options(scipen = 20)
theme_set(theme_minimal())
```

Generating different data sets:

```{r}
# d_bivariate <- data %>%
#   select(ln_gross_expenditure_pc, total_seats, ags, year, state) %>% drop_na()
# d_bivariate_iv <- data %>%
#   select(ln_gross_expenditure_pc, total_seats, ags, year, total_seats_24_y_ago) %>% drop_na()
d_rdd_bivariate <- data %>%
  select(ln_gross_expenditure_pc, total_seats, inhabs_rel_to_cutoff, above_cutoff, inhabitants_treshold_factor, inhabitants_treshold, year, ags, election_year, state, closest, clean_disc_acc_Höhmann, clean_disc_acc_to_my_research) %>%
  drop_na(ln_gross_expenditure_pc, total_seats, inhabs_rel_to_cutoff) %>%
  # Repeat (bandwidth) window calculation for data subsets
  mutate(
    closest = base::rank(abs(inhabs_rel_to_cutoff), ties.method = "last"),
    closest = closest/max(closest),
  )

# d_controls <- data %>%
#   select(ln_gross_expenditure_pc, total_seats, ags, year, inh_tot, pop_over65, unempl_rate, total_area_ha,
#     share_working_age, kreisfreie_stadt, stadt, years_since_last_elec, state) %>%
#   drop_na()
# d_controls_iv <- data %>%
#   select(ln_gross_expenditure_pc, total_seats, ags, year, total_seats_24_y_ago, inh_tot, pop_over65,
#          unempl_rate, total_area_ha, share_working_age, kreisfreie_stadt, stadt,
#          years_since_last_elec) %>%
#   drop_na()
d_rdd <- data %>%
  select(ln_gross_expenditure_pc, total_seats, inhabs_rel_to_cutoff, above_cutoff, closest,
         inhabitants_treshold_factor, year, ags, state,
         inh_tot, pop_over65, unempl_rate, total_area_ha,
         share_working_age, kreisfreie_stadt, stadt, years_since_last_elec) %>%
  drop_na() %>%
  # Repeat (bandwidth) window calculation for data subsets
  mutate(
    closest = base::rank(abs(inhabs_rel_to_cutoff), ties.method = "last"),
    closest = closest/max(closest),
  )
d_ttest <- data %>%
  select(ln_gross_expenditure_pc, inhabs_rel_to_cutoff) %>% drop_na()
```



# Introduction

Sharp RDD mit "intention-to-treat" effect?

Treating all of the cutoffs as one requires a harmonization. This happens according to Egger and Koethenbuerger (2010):

Using the Egger and Koethenbuerger (2010) calculation steps:
$$\tilde{N_i} = N_i/N_d$$
with $N_i$ as the relevant actual population size and $N_d$ as the respective thresholds.


# t test

The most simple thing to do is a simple t test for differences.

```{r}
# 0.1 around cutoff
d_ttest2 <- d_ttest %>%
  filter(abs(inhabs_rel_to_cutoff) < 0.1) # Choose bandwidth
nrow(d_ttest2) / nrow(data) # Share of observations close to threshold
t.test(log(d_ttest2$ln_gross_expenditure_pc[d_ttest2$inhabs_rel_to_cutoff < 0]),
       log(d_ttest2$ln_gross_expenditure_pc[d_ttest2$inhabs_rel_to_cutoff >= 0]))
# 0.05 around cutoff
d_ttest2 <- d_ttest %>%
  filter(abs(inhabs_rel_to_cutoff) < 0.05) # Choose bandwidth
nrow(d_ttest2) / nrow(data) # Share of observations close to threshold
t.test(log(d_ttest2$ln_gross_expenditure_pc[d_ttest2$inhabs_rel_to_cutoff < 0]),
       log(d_ttest2$ln_gross_expenditure_pc[d_ttest2$inhabs_rel_to_cutoff >= 0]))
# 0.01 around cutoff
d_ttest2 <- d_ttest %>%
  filter(abs(inhabs_rel_to_cutoff) < 0.025) # Choose bandwidth
nrow(d_ttest2) / nrow(data) # Share of observations close to threshold
t.test(log(d_ttest2$ln_gross_expenditure_pc[d_ttest2$inhabs_rel_to_cutoff < 0]),
       log(d_ttest2$ln_gross_expenditure_pc[d_ttest2$inhabs_rel_to_cutoff >= 0]))
```

The results are not really consistent when it comes to statistical significance. The difference between both sides also heavily depends on the bandwidth chosen.
Keep in mind, however, that a t test is not exactly appropriate due to the fuzzy nature of the setting: Whether or not municipalities actually take treatment is not accounted for in this approach.

```{r}
rm(d_ttest2)
```


# Manual IV regression

This is how it is done according to ["The Effect" of Nick Huntington-Klein, chapter 20](https://theeffectbook.net/ch-RegressionDiscontinuity.html):
```{r}
df <- d_rdd_bivariate %>%
  filter(closest <= 0.1) # Choose bandwidth window -- similar to Höhmann (2017)
rdd_bivariate <- fixest::feols(ln_gross_expenditure_pc ~
                                 1  | # controls
                                 inhabitants_treshold_factor + year + ags | # fixed-effect controls
                                 # First stage regression:
                                 inhabs_rel_to_cutoff*total_seats ~ # Instrument our standard RDD...
                                 inhabs_rel_to_cutoff*above_cutoff, # ... with being above the cutoff
                               data = df)
summary(rdd_bivariate, vcov = "hetero")
summary(rdd_bivariate, vcov = "threeway", stage = 1:2)
# More tests:
#fixest::fitstat(rdd, ~ ivf1 + ivwald1 + ivf2 + ivwald2)
rm(df)
```

More simplistic version:
```{r}
df <- d_rdd_bivariate %>%
  filter(closest <= 0.1) # Choose bandwidth window -- similar to Höhmann (2017)
rdd <- fixest::feols(ln_gross_expenditure_pc ~
                     1  | # controls
                     inhabitants_treshold_factor + year + ags | # fixed-effect controls
                     # First stage regression:
                     total_seats ~ # Instrument our standard RDD...
                     above_cutoff, # ... with being above the cutoff
                     data = df)
summary(rdd, vcov = "hetero")
summary(rdd, vcov = "threeway", stage = 1:2)
# More tests:
#fixest::fitstat(rdd, ~ ivf1 + ivwald1 + ivf2 + ivwald2)
rm(df, rdd)
```

```{r, eval = FALSE}
df <- d_rdd_bivariate %>%
  filter(closest <= 0.1) # Choose bandwidth window -- similar to Höhmann (2017)
rdd <- fixest::feols(ln_gross_expenditure_pc ~
                     inhabs_rel_to_cutoff  | # controls
                     inhabitants_treshold_factor + year + ags | # fixed-effect controls
                     # First stage regression:
                     total_seats ~ # Instrument our standard RDD...
                     above_cutoff, # ... with being above the cutoff
                     data = df)
summary(rdd, vcov = "hetero")
summary(rdd, vcov = "threeway", stage = 1:2)
rm(df, rdd)
```

Include polynomials:

```{r}
df <- d_rdd_bivariate %>%
  filter(closest <= 0.1) # Choose bandwidth window -- similar to Höhmann (2017)
# Increasing the degree of polynomials
fixest::feols(ln_gross_expenditure_pc ~
                1 | # controls
                inhabitants_treshold_factor + year + ags | # fixed-effect controls
                # First stage regression:
                inhabs_rel_to_cutoff*total_seats ~ # Instrument our standard RDD...
                inhabs_rel_to_cutoff*above_cutoff, # ... with being above the cutoff
              #vcov = "threeway",
              data = df)
fixest::feols(ln_gross_expenditure_pc ~
                1  | # controls
                inhabitants_treshold_factor + year + ags | # fixed-effect controls
                # First stage regression:
                poly(inhabs_rel_to_cutoff, 2)*total_seats ~ # Instrument our standard RDD...
                poly(inhabs_rel_to_cutoff, 2)*above_cutoff, # ... with being above the cutoff
              vcov = "threeway",
              data = df)
fixest::feols(ln_gross_expenditure_pc ~
                1  | # controls
                inhabitants_treshold_factor + year + ags | # fixed-effect controls
                # First stage regression:
                poly(inhabs_rel_to_cutoff, 3)*total_seats ~ # Instrument our standard RDD...
                poly(inhabs_rel_to_cutoff, 3)*above_cutoff, # ... with being above the cutoff
              vcov = "threeway",
              data = df)
fixest::feols(ln_gross_expenditure_pc ~
                1  | # controls
                inhabitants_treshold_factor + year + ags | # fixed-effect controls
                # First stage regression:
                poly(inhabs_rel_to_cutoff, 4)*total_seats ~ # Instrument our standard RDD...
                poly(inhabs_rel_to_cutoff, 4)*above_cutoff, # ... with being above the cutoff
              vcov = "threeway",
              data = df)
fixest::feols(ln_gross_expenditure_pc ~
                1  | # controls
                inhabitants_treshold_factor + year + ags | # fixed-effect controls
                # First stage regression:
                poly(inhabs_rel_to_cutoff, 5)*total_seats ~ # Instrument our standard RDD...
                poly(inhabs_rel_to_cutoff, 5)*above_cutoff, # ... with being above the cutoff
              vcov = "threeway",
              data = df)
fixest::feols(ln_gross_expenditure_pc ~
                1  | # controls
                inhabitants_treshold_factor + year + ags | # fixed-effect controls
                # First stage regression:
                poly(inhabs_rel_to_cutoff, 6)*total_seats ~ # Instrument our standard RDD...
                poly(inhabs_rel_to_cutoff, 6)*above_cutoff, # ... with being above the cutoff
              vcov = "threeway",
              data = df)
rm(df)
```
The results do not differ in their interpretation. The coefficient of interest, `fit_total_seats`, indicates a single-digit decrease of spending at the cutoff but is never statistically significantly different from zero.

Dropping polynomials but adding controls:

```{r}
df <- d_rdd %>%
  filter(closest <= 0.1) # Choose bandwidth window -- similar to Höhmann (2017)
# Continuously adding covariates
fixest::feols(ln_gross_expenditure_pc ~
                csw0(inh_tot, pop_over65, unempl_rate, total_area_ha,
                     share_working_age, kreisfreie_stadt, stadt, years_since_last_elec) | # controls
                inhabitants_treshold_factor + year + ags | # fixed-effect controls
                # First stage regression:
                inhabs_rel_to_cutoff*total_seats ~ # Instrument our standard RDD...
                inhabs_rel_to_cutoff*above_cutoff, # ... with being above the cutoff
              vcov = "threeway",
              data = df)
# Model with covariates
rdd_w_covs <- fixest::feols(ln_gross_expenditure_pc ~
                              inh_tot + pop_over65 + unempl_rate + total_area_ha + share_working_age +
                              kreisfreie_stadt + stadt + years_since_last_elec | # controls
                              inhabitants_treshold_factor + year + ags | # fixed-effect controls
                              # First stage regression:
                              inhabs_rel_to_cutoff*total_seats ~ # Instrument our standard RDD...
                              inhabs_rel_to_cutoff*above_cutoff, # ... with being above the cutoff
                            data = df)
summary(rdd_w_covs, vcov = "threeway")
rm(df)
```
Interpretation similar to the polynomial case: decrease in the single digits but not significant.

Varying bandwidth:

```{r}
# Baseline
d_rdd_bivariate %>%
  filter(closest <= 0.1) %>% # Choose bandwidth window -- similar to Höhmann (2017)
  fixest::feols(ln_gross_expenditure_pc ~
                  1  | # controls
                  inhabitants_treshold_factor + year + ags | # fixed-effect controls
                  # First stage regression:
                  inhabs_rel_to_cutoff*total_seats ~ # Instrument our standard RDD...
                  inhabs_rel_to_cutoff*above_cutoff, # ... with being above the cutoff
                vcov = "threeway")
# Half the window
d_rdd_bivariate %>%
  filter(closest <= 0.05) %>% # Choose bandwidth window
  fixest::feols(ln_gross_expenditure_pc ~
                  1  | # controls
                  inhabitants_treshold_factor + year + ags | # fixed-effect controls
                  # First stage regression:
                  inhabs_rel_to_cutoff*total_seats ~ # Instrument our standard RDD...
                  inhabs_rel_to_cutoff*above_cutoff, # ... with being above the cutoff
                vcov = "threeway")
# Double the window size
d_rdd_bivariate %>%
  filter(closest <= 0.2) %>% # Choose bandwidth window
  fixest::feols(ln_gross_expenditure_pc ~
                  1  | # controls
                  inhabitants_treshold_factor + year + ags | # fixed-effect controls
                  # First stage regression:
                  inhabs_rel_to_cutoff*total_seats ~ # Instrument our standard RDD...
                  inhabs_rel_to_cutoff*above_cutoff, # ... with being above the cutoff
                vcov = "threeway")
# More tests:
#fixest::fitstat(rdd, ~ ivf1 + ivwald1 + ivf2 + ivwald2)
#rm(df, rdd)
```
Interpretation as before: Non-significant decrease in the single digits.

## Summary

Comparing the two main models:
```{r}
etable(rdd_bivariate, rdd_w_covs)
```

```{r}
etable(rdd_bivariate, rdd_w_covs,
       file = "tables/rdd_iv.tex",
       replace = TRUE,
       # Table settings
       drop = "!Council size",
       dict = c(total_seats = "Council size",
                ln_gross_expenditure_pc = "Ln of gross expenditure p. c."),
       signif.code = c("***"=0.001, "**"=0.01, "*"=0.05, "'"=0.10),
       headers = c("\\acs{RDD} \\acs{wo} covariates", "\\acs{RDD} \\acs{w} covariates"),
       extralines = list(
         "-^Controls" = c("No", "Yes")#,
         #"-_\\acs{SE}" = rep("by threshold, \\acs{yr} & \\acs{mcp}", 2),
         #"_^Data sample" = c(rep("All data", 3), "\\acs{BY} only")
         ),
       # LaTeX settings
       title = "Results of the \\ac{IV} \\ac{RDD}",
       label = "tab:rdd_iv",
       notes = paste("\\footnotesize{*Notes:* Results of the \\ac{IV} \\ac{RDD}.",
                     tex_control_text,
                     "Standard errors clustered at the threshold, year and municipality level in parentheses.",
                     tex_signif_text),
       style.tex = style.tex(
         fixef.suffix = " \\ac{FE}"
       )
       )
```

```{r}
rm(rdd_bivariate, rdd_w_covs)
```




# `rdrobust` package

## Bivariate RDD

Bivariate RDD without FE:

```{r rdd_bi_wo_fe}
rdd <-
  rdrobust::rdrobust(
    y = d_rdd_bivariate$ln_gross_expenditure_pc,
    x = d_rdd_bivariate$inhabs_rel_to_cutoff,
    fuzzy = d_rdd_bivariate$total_seats
  )
summary(rdd)
rdd_bi <-
  rdrobust::rdrobust(
    y = d_rdd_bivariate$ln_gross_expenditure_pc,
    x = d_rdd_bivariate$inhabs_rel_to_cutoff,
    fuzzy = d_rdd_bivariate$total_seats,
    cluster = d_rdd_bivariate$inhabitants_treshold_factor
  )
summary(rdd_bi)
```

Bivariate RDD with one-way FE:

```{r, eval=FALSE}
# to do: remove eval=FALSE
rdd_fe_th <-
  rdrobust::rdrobust(
    y = d_rdd_bivariate$ln_gross_expenditure_pc,
    x = d_rdd_bivariate$inhabs_rel_to_cutoff,
    fuzzy = d_rdd_bivariate$total_seats,
    cluster = d_rdd_bivariate$inhabitants_treshold_factor,
    covs = model.matrix( ~ d_rdd_bivariate$inhabitants_treshold_factor)
  )
summary(rdd_fe_th)
rdd_fe_yr <-
  rdrobust::rdrobust(
    y = d_rdd_bivariate$ln_gross_expenditure_pc,
    x = d_rdd_bivariate$inhabs_rel_to_cutoff,
    fuzzy = d_rdd_bivariate$total_seats,
    cluster = d_rdd_bivariate$inhabitants_treshold_factor,
    covs = model.matrix( ~ d_rdd_bivariate$year)
  )
summary(rdd_fe_yr)
rdd_fe_state <-
  rdrobust::rdrobust(
    y = d_rdd_bivariate$ln_gross_expenditure_pc,
    x = d_rdd_bivariate$inhabs_rel_to_cutoff,
    fuzzy = d_rdd_bivariate$total_seats,
    cluster = d_rdd_bivariate$inhabitants_treshold_factor,
    covs = model.matrix( ~ d_rdd_bivariate$state)
  )
summary(rdd_fe_state)
```


The threshold FE appear very important: Without them, barely any effect visible at the first stage. But that makes sense even theoretically as the threshold level indicates on which (sharp) side of the cutoff we are.

Bivariate RDD with threeway FE:
```{r}
rdd_bi_fe <-
  rdrobust::rdrobust(
    y = d_rdd_bivariate$ln_gross_expenditure_pc,
    x = d_rdd_bivariate$inhabs_rel_to_cutoff,
    fuzzy = d_rdd_bivariate$total_seats,
    cluster = d_rdd_bivariate$inhabitants_treshold_factor,
    covs = model.matrix( ~ d_rdd_bivariate$inhabitants_treshold_factor + d_rdd_bivariate$year + d_rdd_bivariate$state)
  )
summary(rdd_bi_fe)
```

Using the `rdrobust` package, some things seem either computionally infeasible or impossible by design. Municipality FE take forever to run and are henceforth not considered (but state FE instead).

```{r, eval = FALSE}
# Takes forever to run
rdd_fe_ags <-
  rdrobust::rdrobust(
    y = d_rdd_bivariate$ln_gross_expenditure_pc,
    x = d_rdd_bivariate$inhabs_rel_to_cutoff,
    fuzzy = d_rdd_bivariate$total_seats,
    cluster = d_rdd_bivariate$inhabitants_treshold_factor,
    covs = model.matrix( ~ d_rdd_bivariate$ags)
  )
summary(rdd_fe_ags)
```

Choosing multiple cluster variables appears not possible and that is likely by design as the documentation states: "`cluster` indicates the cluster ID variable" in a singular form:
```{r, eval = FALSE}
rdd_fe <-
  rdrobust::rdrobust(
    y = d_rdd_bivariate$ln_gross_expenditure_pc,
    x = d_rdd_bivariate$inhabs_rel_to_cutoff,
    fuzzy = d_rdd_bivariate$total_seats,
    cluster = model.matrix( ~ d_rdd_bivariate$inhabitants_treshold_factor + d_rdd_bivariate$year)
  )
# or:
rdd_fe <-
  rdrobust::rdrobust(
    y = d_rdd_bivariate$ln_gross_expenditure_pc,
    x = d_rdd_bivariate$inhabs_rel_to_cutoff,
    fuzzy = d_rdd_bivariate$total_seats,
    cluster = d_rdd_bivariate$inhabitants_treshold_factor + d_rdd_bivariate$year
  )
```


## Multivariate RDD

Multivariate RDD without FE:
```{r, rdrobust_multi_fe}
rdd <-
  rdrobust::rdrobust(
    y = d_rdd$ln_gross_expenditure_pc,
    x = d_rdd$inhabs_rel_to_cutoff,
    fuzzy = d_rdd$total_seats,
    covs = d_rdd$inh_tot + d_rdd$pop_over65 + d_rdd$unempl_rate + # controls
      d_rdd$total_area_ha + d_rdd$share_working_age + # controls (cont.)
      model.matrix( ~ d_rdd$kreisfreie_stadt + d_rdd$stadt + d_rdd$years_since_last_elec) # dummy controls
  )
summary(rdd)
rdd_multi <-
  rdrobust::rdrobust(
    y = d_rdd$ln_gross_expenditure_pc,
    x = d_rdd$inhabs_rel_to_cutoff,
    fuzzy = d_rdd$total_seats,
    cluster = d_rdd$inhabitants_treshold_factor,
    covs = d_rdd$inh_tot + d_rdd$pop_over65 + d_rdd$unempl_rate + # controls
      d_rdd$total_area_ha + d_rdd$share_working_age + # controls (cont.)
      model.matrix( ~ d_rdd$kreisfreie_stadt + d_rdd$stadt + d_rdd$years_since_last_elec) # dummy controls
  )
summary(rdd_multi)
```

Multivariate threeway RDD:
```{r, rdd_multi_fe}
rdd_multi_fe <-
  rdrobust::rdrobust(
    y = d_rdd$ln_gross_expenditure_pc,
    x = d_rdd$inhabs_rel_to_cutoff,
    fuzzy = d_rdd$total_seats,
    cluster = d_rdd$inhabitants_treshold_factor,
    covs = model.matrix( ~ d_rdd$inhabitants_treshold_factor + d_rdd$year + d_rdd$state + # FE
                           d_rdd$kreisfreie_stadt + d_rdd$stadt + d_rdd$years_since_last_elec) + # dummy controls
      d_rdd$inh_tot + d_rdd$pop_over65 + d_rdd$unempl_rate + # controls
      d_rdd$total_area_ha + d_rdd$share_working_age # controls (cont.)
  )
summary(rdd_multi_fe)
```

Comparison of the four main models:
```{r, rdrobust_summary}
summary(rdd_bi)
summary(rdd_bi_fe)
summary(rdd_multi)
summary(rdd_multi_fe)
```

## Manual export to LaTeX

```{r}
# Function to generate significance stars out of p values
assign_stars <- function(p) {
  if (p < 0.001) {
    print("***")
  }
  else if (p < 0.01) {
    print("**")
  }
  else if (p < 0.05) {
    print("*")
  }
  else if (p < 0.1) {
    print("'")
  }
}
round_decimals <- 4
```
```{r}
rdd_tex_export <- tibble(
  `Dependent variable:` = c("Model", "", "Council size", "", "", "Controls", "Threshold FE", "Year FE", "State FE", "Observations", "Bandwidth", "Observations below", "Observations above"),
  `Ln of gross expenditure p. c.` = c("RDD w/o covariates", "(1)", paste0(round(rdd_bi$Estimate[1], round_decimals), assign_stars(rdd_bi$pv[3])), paste0("(", round(rdd_bi$se[1], round_decimals), ")"), paste0("[", round(rdd_bi$ci[3,1], 3), ", ", round(rdd_bi$ci[3,2], 3), "]"), rep("No", 4), sum(rdd_bi$N), round(rdd_bi$bws[1,1], round_decimals), rdd_bi$N_h[1], rdd_bi$N_h[2]),
  `2` = c("FE RDD w/o covariates", "(2)", paste0(round(rdd_bi_fe$Estimate[1], round_decimals), assign_stars(rdd_bi_fe$pv[3])), paste0("(", round(rdd_bi_fe$se[1], round_decimals), ")"), paste0("[", round(rdd_bi_fe$ci[3,1], 3), ", ", round(rdd_bi_fe$ci[3,2], 3), "]"), "No", rep("Yes", 3), sum(rdd_bi_fe$N), round(rdd_bi_fe$bws[1,1], round_decimals), rdd_bi_fe$N_h[1], rdd_bi_fe$N_h[2]),
  `3` = c("RDD w/ covariates", "(3)", paste0(round(rdd_multi$Estimate[1], round_decimals), assign_stars(rdd_multi$pv[3])), paste0("(", round(rdd_multi$se[1], round_decimals), ")"), paste0("[", round(rdd_multi$ci[3,1], 3), ", ", round(rdd_multi$ci[3,2], 3), "]"), "Yes", rep("No", 3), sum(rdd_multi$N), round(rdd_multi$bws[1,1], round_decimals), rdd_multi$N_h[1], rdd_multi$N_h[2]),
  `4` = c("FE RDD w/ covariates", "(4)", paste0(round(rdd_multi_fe$Estimate[1], round_decimals), assign_stars(rdd_multi_fe$pv[3])), paste("(", round(rdd_multi_fe$se[1], round_decimals), ")"), paste0("[", round(rdd_multi_fe$ci[3,1], 3), ", ", round(rdd_multi_fe$ci[3,2], 3), "]"), rep("Yes", 4), sum(rdd_multi_fe$N), round(rdd_multi_fe$bws[1,1], round_decimals), rdd_multi_fe$N_h[1], rdd_multi_fe$N_h[2])
  )
```

```{r}
print(
  xtable::xtable(
    rdd_tex_export,
    align = "llcccc"
    ),
  file = "tables/rdd_rdrobust.tex",
  booktabs = TRUE,
  floating = FALSE,
  hline.after = c(-1, -1, 2, 5, 9, nrow(rdd_tex_export), nrow(rdd_tex_export)),
  include.rownames = FALSE
)
```

## Plots

Default plots look strange for some reason:
```{r}
rdrobust::rdplot(y = d_rdd_bivariate$ln_gross_expenditure_pc, x = d_rdd_bivariate$inhabs_rel_to_cutoff)
ggplot(data = d_rdd_bivariate) +
  geom_density(aes(inhabs_rel_to_cutoff))
ggplot(data = d_rdd_bivariate) +
  geom_point(aes(x = inhabs_rel_to_cutoff, y = ln_gross_expenditure_pc))
```

Plotting the estimated model from the previous section:
```{r}
#https://stackoverflow.com/questions/56884210/rdrobust-plotting-graphs-for-local-polynomial-estimation/57614447
rdplot <- rdrobust::rdplot(
  y = d_rdd$ln_gross_expenditure_pc,
  x = d_rdd$inhabs_rel_to_cutoff,
  binselect = "es",
  scale = 5,
  kernel = tolower(rdd_multi_fe$kernel),
  p = rdd_multi_fe$p,
  h = rdd_multi_fe$bws[1],
  covs = model.matrix( ~ d_rdd$inhabitants_treshold_factor + d_rdd$year + d_rdd$state + # FE
                         d_rdd$kreisfreie_stadt + d_rdd$stadt + d_rdd$years_since_last_elec) + # dummy controls
    d_rdd$inh_tot + d_rdd$pop_over65 + d_rdd$unempl_rate + # controls
    d_rdd$total_area_ha + d_rdd$share_working_age, # controls (cont.)
  x.lim = c(-rdd_multi_fe$bws[1], rdd_multi_fe$bws[1]),
  #title = "RD Plot - Senate Elections Data",
  x.label = "Population",
  y.label = "Ln of gross expenditure p. c.",
  ci = 95)
rdplot
```

to do: Manual plot instead?


to do: fuzzy argument (i. e. treatment indicator) binary; sharp RDD (intention to treat)


## Robustness Checks

The RDD FE model without covariates will be regarded as the baseline model. Hence, write a wrapper function to ease the use of the model:

```{r, robustness_function}
rdrobust_fe_model <- function(cc = NULL, pp = NULL, qq = NULL, hh = NULL, bb = NULL, kkernel = "tri", bbwselect = "mserd", vvce = "nn") {
  rdrobust::rdrobust(
    y = d_rdd_bivariate$ln_gross_expenditure_pc,
    x = d_rdd_bivariate$inhabs_rel_to_cutoff,
    c = cc,
    fuzzy = d_rdd_bivariate$total_seats,
    cluster = d_rdd_bivariate$inhabitants_treshold_factor,
    covs = model.matrix( ~ d_rdd_bivariate$inhabitants_treshold_factor + d_rdd_bivariate$year + d_rdd_bivariate$state),
    # set parameters to run for robustness tests; set them to rdrobust defaults
    p = pp,
    q = qq,
    h = hh,
    b = bb,
    kernel = kkernel,
    bwselect = bbwselect,
    vce = vvce
  )
}
```
```{r, eval=FALSE}
# to do: remove eval=FALSE
rdd <- rdrobust_fe_model()
summary(rdd) # equal to rdd_bi_fe model
```


### Different RDD specifications

Vary p, the local polynomial. Conclusions remain. On the first stage, council size jumps by a value somewhat larger than 1 at the threshold (highly statistically significant). The second stage, however, remains insignificant, with some p values around 0.2, the others are (in part way) larger. The coefficient is always slightly positive.
```{r, eval=FALSE}
# to do: remove eval=FALSE
for (vary_p in 0:6) {
  print(paste("polynomial of degree", vary_p))
  rdd <- rdrobust_fe_model(pp = vary_p)
  summary(rdd)
}
```
Vary q, the "local-polynomial used to construct the bias correction". Conclusions similar to varying p: Higly significant first stage across all `q`s, non-significant second stage (p values as low as 0.2) and positive around 1%.
```{r, rdd_vary_q, eval=FALSE}
# to do: remove eval=FALSE
for (vary_q in 2:6) {
  print(paste("polynomial of degree", vary_q))
  rdd <- rdrobust_fe_model(qq = vary_q)
  summary(rdd)
}
```

Vary kernel: No large differences between kernels.
```{r, rdd_vary_kernel, eval=FALSE}
# to do: remove eval=FALSE
for (vary_kernel in c("tri", "epa", "uni")) {
  print(paste("kernel:", vary_kernel))
  rdd <- rdrobust_fe_model(kkernel = vary_kernel)
  summary(rdd)
}
```

Vary variance-covariance matrix: The `hc` vce appear extremely similar. Conclusions, however, are not altered.
```{r, rdd_vary_vcov, eval=FALSE}
# to do: remove eval=FALSE
for (vary_vcov in c("nn", "hc0", "hc1", "hc2", "hc3")) {
  print(paste("vce:", vary_vcov))
  rdd <- rdrobust_fe_model(vvce = vary_vcov)
  summary(rdd)
}
```

### Sensitivity analysis

Vary the bandwidths `h` and `b`, manually set those instead of using a data-driven algorithm. If `h` is manually set to a certain value, the function sets `b` to the very same value. However, since the two are typically not in the same ballpark when calculated automatically (i. e. in a data-driven way), I will run the two loops separately with different values.
Conclusion: In these cases, varying the parameters does matter for the result (this is not the case with `p` and `q`). The larger the bandwidth, the larger the first-stage coefficient. In addition, the significance level of the second stage coefficient increases (the p value decreases) in the bandwidth. The value of the coefficient of interest is steady at a bit more than 1%. Note, however, that the last models include more than half of the sample size in the calculation, potentially invalidating the research design.
```{r, rdd_bw_manual, eval=FALSE}
# to do: remove eval=FALSE
for (vary_h in seq(0.02, 0.2, 0.03)) {
  print(paste("polynomial of degree", vary_h))
  rdd <- rdrobust_fe_model(hh = vary_h)
  summary(rdd)
}
```
Apparently, the bandwidth `b` cannot be set manually. Perhaps change `rho` parameter or set `b` manually and `b` via the `bwselect()` function.
```{r, eval=FALSE}
for (vary_b in seq(0.15, 0.45, 0.075)) {
  print(paste("RDD with bandwidth b =", vary_b))
  rdd <- rdrobust_fe_model(bb = vary_b)
  summary(rdd)
}
```

Window bandwidth selection (similar to Höhmann, 2017; i. e. do not use automatic bandwidth selection algorithm but all observations within the window chosen). For large window values (>0.05), the conclusions drawn remain unchanged. For window values <=0.05, however, the coefficients for council size at the second stage are significant. Nevertheless, the sign switches: For low window values, there is a negative effect (-6% and -3%, respectively), for higher window cutoffs, there is a weakly positive effect. Regarding the sample size, note that even the smallest window yields a sample size of more than 1000 observations.
```{r, rdd_window, eval=FALSE}
# to do: remove eval=FALSE
rdd_vary_window <-
  tibble(window = "", point_estimate = "", ci_lower = "", ci_upper = "") %>%
  mutate(across(everything(), as.numeric))
for (vary_window in seq(0.01, 0.25, 0.01)) {
  print(paste("RDD with window: ", vary_window))
  df <- d_rdd_bivariate %>%
    filter(closest <= vary_window)
  str(vary_window)
  rdd <-
    rdrobust::rdrobust(
      y = df$ln_gross_expenditure_pc,
      x = df$inhabs_rel_to_cutoff,
      fuzzy = df$total_seats,
      cluster = df$inhabitants_treshold_factor,
      covs = model.matrix( ~ df$inhabitants_treshold_factor + df$year + df$state),
      h = 10 # 10 is larger than any absolute value of the running variable => use all observations
  )
  summary(rdd)
  rdd_vary_window <- rdd_vary_window %>%
    dplyr::add_row(
      window = vary_window,
      point_estimate = rdd$coef[1],
      ci_lower = rdd$ci[3,1],
      ci_upper = rdd$ci[3,2]
  )
}
rdd_vary_window <- rdd_vary_window %>% drop_na()
```
Plot windows. Coefficients and CIs need not overlap because standard coefficients are paired with robust-corrected CIs.
```{r, rdd_window_plot, eval=FALSE}
# to do: remove eval=FALSE
ggplot2::ggplot(data = rdd_vary_window, aes(x = window, y = point_estimate)) +
  geom_point(size = 1.5) +
  geom_errorbar(aes(ymin = ci_lower, ymax = ci_upper), width = 0.005) +
  scale_x_continuous(labels = scales::percent) +
  scale_y_continuous(labels = scales::percent) +
  labs(x = "Window around the threshold", y = "Increase in spending at the threshold")
ggsave(filename = "plots/rdrobust_bw_window.pdf", width = 6, height = 6*9/16)
```


Different `rdbwselect` options: Most bandwidth selection algorithms yield similar results to the default one. One or two, however, gain statistical significance for the regressor of interest by virtue of a larger bandwidth.
```{r, eval=FALSE}
# to do: remove eval=FALSE
rdd_vary_bwselect <-
  tibble(bw_sel_algo = "", point_estimate = "", ci_lower = "", ci_upper = "") %>%
  mutate(across(2:4, as.numeric))
for (vary_bwselect in c("mserd", "msetwo", "msesum", "msecomb1", "msecomb2", "cerrd", "certwo", "cersum", "cercomb1", "cercomb2")) {
  print(paste("Bandwidth selection algorithm:", vary_bwselect))
  rdd <- rdrobust_fe_model(bbwselect = vary_bwselect)
  summary(rdd)
  rdd_vary_bwselect <- rdd_vary_bwselect %>%
    dplyr::add_row(
      bw_sel_algo = vary_bwselect,
      point_estimate = rdd$coef[1],
      ci_lower = rdd$ci[3,1],
      ci_upper = rdd$ci[3,2]
  )
}
rdd_vary_bwselect <- rdd_vary_bwselect %>% drop_na()
```
Plot bandwidth selection algorithms. Coefficients and CIs need not overlap because standard coefficients are paired with robust-corrected CIs.
Note: In general may be a good idea, but hard to explain all bandwidth selectors in the paper just for the purpose of this plot...
```{r, rdd_window_plot2, eval=FALSE}
# to do: remove eval=FALSE
ggplot2::ggplot(data = rdd_vary_bwselect, aes(x = bw_sel_algo, y = point_estimate)) +
  geom_point(size = 1.5) +
  geom_errorbar(aes(ymin = ci_lower, ymax = ci_upper), width = 0.005) +
  scale_y_continuous(labels = scales::percent) +
  labs(x = "Bandwidth selection procedure", y = "Increase in spending at the threshold")
```

```{r}
rm(list=ls(pattern="^panel_"), rdd)
```


### Dropping confounded thresholds

Dropping confounded thresholds as determined by my own legal research: The conclusions are quite similar for both "Höhmann's" and "my" thresholds -- the effect of council size is small and positive (in the really small single-digits) but nonsignificant for both counfounded as well as nonconfounded thresholds.

Note: (to do) maybe you could also solve this by interacting `clean_dis_acc_to_my_research`.

```{r, rdd_confounded_th_my}
# Effect for confounded thresholds
df <- d_rdd_bivariate %>%
    filter(clean_disc_acc_to_my_research == 0)
rdd <-
  rdrobust::rdrobust(
    y = df$ln_gross_expenditure_pc,
    x = df$inhabs_rel_to_cutoff,
    fuzzy = df$total_seats,
    cluster = df$inhabitants_treshold_factor,
    covs = model.matrix(~ df$inhabitants_treshold_factor + df$year + df$state)
  )
summary(rdd)
# Effect for noncounfounded thresholds
df <- d_rdd_bivariate %>%
    filter(clean_disc_acc_to_my_research == 1)
rdd <-
  rdrobust::rdrobust(
    y = df$ln_gross_expenditure_pc,
    x = df$inhabs_rel_to_cutoff,
    fuzzy = df$total_seats,
    cluster = df$inhabitants_treshold_factor,
    covs = model.matrix(~ df$inhabitants_treshold_factor + df$year + df$state)
  )
summary(rdd)
```

Dropping confounded thresholds as determined by Höhmann (2017):

```{r rdd_confounded_th_hohmann}
# Effect for confounded thresholds
df <- d_rdd_bivariate %>%
    filter(clean_disc_acc_Höhmann == 0)
rdd <-
  rdrobust::rdrobust(
    y = df$ln_gross_expenditure_pc,
    x = df$inhabs_rel_to_cutoff,
    fuzzy = df$total_seats,
    cluster = df$inhabitants_treshold_factor,
    covs = model.matrix(~ df$inhabitants_treshold_factor + df$year + df$state)
  )
summary(rdd)
# Effect for noncounfounded thresholds
df <- d_rdd_bivariate %>%
    filter(clean_disc_acc_Höhmann == 1)
rdd <-
  rdrobust::rdrobust(
    y = df$ln_gross_expenditure_pc,
    x = df$inhabs_rel_to_cutoff,
    fuzzy = df$total_seats,
    cluster = df$inhabitants_treshold_factor,
    covs = model.matrix(~ df$inhabitants_treshold_factor + df$year + df$state)
  )
summary(rdd)
```


### Placebo thresholds

First attempt

```{r, rdrobust_place1, eval=FALSE}
# to do: remove eval=FALSE
rdd_placebo <-
  tibble(placebo_c = "", point_estimate = "", ci_lower = "", ci_upper = "", p = "", effective_n = "") %>%
  mutate(across(everything(), as.numeric))
vector <- seq(from = -(2+2/3), to = 2/3, by = 1/6) # Choose vector of arbitrary placebo cutoffs
#vector <- vector[!vector %in% (-2-1/3)]
vector <- vector[-c(3, 21)] # Drop cutoffs that yield errors
for (i in vector) {
  print(paste("Cutoff at:", i))
  rdd <- rdrobust_fe_model(cc = i)
  #summary(rdd)
  rdd_placebo <- rdd_placebo %>%
    dplyr::add_row(
      placebo_c = i,
      point_estimate = rdd$coef[1],
      ci_lower = rdd$ci[3,1],
      ci_upper = rdd$ci[3,2],
      p = rdd$pv[3],
      effective_n = sum(rdd$N_h)
  )
}
rdd_placebo <- rdd_placebo %>% drop_na()
```
Visualization of placebo cutoffs:
```{r, rdrobust_placebo_viz1, eval=FALSE}
# to do: remove eval=FALSE
df <- rdd_placebo %>%
  #tidyr::drop_na() %>%
  filter(abs(ci_upper) < 100 | abs(ci_lower) < 100) %>%
  mutate(effective_n = trimws(format(effective_n, big.mark = ",") ) ) # add big mark
ggplot2::ggplot(df) +
  geom_point(aes(x = placebo_c, y = point_estimate), size = 1.5, colour = ifelse(df$p <= 0.05, 2, 1)) +
  geom_errorbar(aes(x = placebo_c, ymin = ci_lower, ymax = ci_upper),
                colour = ifelse(df$p <= 0.05, 2, 1),
                linetype = ifelse(df$p <= 0.05, 2, 1)) +
  geom_text(aes(x = placebo_c, y = ci_lower, label = effective_n),
            colour = ifelse(df$p <= 0.05, 2, 1), vjust = 1, size = 2.3, check_overlap = TRUE) +
  scale_y_continuous(labels = scales::percent) +
  labs(x = "Cutoff of the running variable", y = "Increase in spending at the threshold")
ggsave(filename = "plots/rdrobust_placebo_wide.pdf", width = 6, height = 6*9/16)
rm(df, vector)
```

Second attempt: Regular cutoffs within the inter-quartile range.

```{r, rdrobust_place2, eval=FALSE}
# to do: remove eval=FALSE
rdd_placebo <-
  tibble(placebo_c = "", point_estimate = "", ci_lower = "", ci_upper = "", p = "", effective_n = "") %>%
  mutate(across(everything(), as.numeric))
vector <- seq(from = (-0.15), to = (0.18), by = 0.03) # Choose vector of arbitrary placebo cutoffs
for (i in vector) {
  print(paste("Cutoff at:", i))
  rdd <- rdrobust_fe_model(cc = i)
  #summary(rdd)
  rdd_placebo <- rdd_placebo %>%
    dplyr::add_row(
      placebo_c = i,
      point_estimate = rdd$coef[1],
      ci_lower = rdd$ci[3,1],
      ci_upper = rdd$ci[3,2],
      p = rdd$pv[3],
      effective_n = sum(rdd$N_h)
  )
}
rdd_placebo <- rdd_placebo %>% drop_na()
```
Visualization of placebo cutoffs:
```{r, rdrobust_placebo_viz2, eval=FALSE}
# to do: remove eval=FALSE
df <- rdd_placebo %>%
  #tidyr::drop_na() %>%
  #filter(abs(ci_upper) < 100 | abs(ci_lower) < 100) %>%
  mutate(effective_n = paste0("n=", trimws(format(effective_n, big.mark = ",") ) ) ) # add big mark
ggplot2::ggplot(df) +
  geom_point(aes(x = placebo_c, y = point_estimate), size = 1.5, colour = ifelse(df$p <= 0.05, 2, 1)) +
  geom_errorbar(aes(x = placebo_c, ymin = ci_lower, ymax = ci_upper),
                colour = ifelse(df$p <= 0.05, 2, 1),
                linetype = ifelse(df$p <= 0.05, 2, 1)) +
  geom_text(aes(x = placebo_c, y = ci_lower, label = effective_n),
            colour = ifelse(df$p <= 0.05, 2, 1), vjust = 1) +
  scale_y_continuous(labels = scales::percent) +
  labs(x = "Cutoff of the running variable", y = "Increase in spending at the threshold")
ggsave(filename = "plots/rdrobust_placebo1.pdf", width = 6, height = 6*9/16)
rm(df, vector)
```

Third attempt: Random cutoffs within the inter-quartile range.

```{r, rdrobust_place3, eval=FALSE}
# to do: remove eval=FALSE
rdd_placebo <-
  tibble(placebo_c = "", point_estimate = "", ci_lower = "", ci_upper = "", p = "", effective_n = "") %>%
  mutate(across(everything(), as.numeric))
set.seed(1234)
vector <- runif(n = 10, min = -0.15, max = 0.18) # Choose vector of random placebo cutoffs
for (i in vector) {
  print(paste("Cutoff at:", i))
  rdd <- rdrobust_fe_model(cc = i)
  #summary(rdd)
  rdd_placebo <- rdd_placebo %>%
    dplyr::add_row(
      placebo_c = i,
      point_estimate = rdd$coef[1],
      ci_lower = rdd$ci[3,1],
      ci_upper = rdd$ci[3,2],
      p = rdd$pv[3],
      effective_n = sum(rdd$N_h)
  )
}
rdd_placebo <- rdd_placebo %>% drop_na()
```
Visualization of placebo cutoffs:
```{r, rdrobust_placebo_viz3, eval=FALSE}
# to do: remove eval=FALSE
df <- rdd_placebo %>%
  #tidyr::drop_na() %>%
  #filter(abs(ci_upper) < 100 | abs(ci_lower) < 100) %>%
  mutate(effective_n = paste0("n=", trimws(format(effective_n, big.mark = ",") ) ) ) # add big mark
ggplot2::ggplot(df) +
  geom_point(aes(x = placebo_c, y = point_estimate), size = 1.5, colour = ifelse(df$p <= 0.05, 2, 1)) +
  geom_errorbar(aes(x = placebo_c, ymin = ci_lower, ymax = ci_upper),
                colour = ifelse(df$p <= 0.05, 2, 1),
                linetype = ifelse(df$p <= 0.05, 2, 1)) +
  geom_text(aes(x = placebo_c, y = ci_lower, label = effective_n),
            colour = ifelse(df$p <= 0.05, 2, 1), vjust = 1) +
  scale_y_continuous(labels = scales::percent) +
  labs(x = "Cutoff of the running variable", y = "Increase in spending at the threshold")
ggsave(filename = "plots/rdrobust_placebo2.pdf", width = 6, height = 6*9/16)
rm(df, vector)
```


### Donut-hole RDD


### Separate years/states

**This section should be sorted into heterogeneity**

For each year: Not much variation in the results here (as expected)
```{r}
all_years <- d_rdd_bivariate %>% distinct(year) %>% pull()
for (i in all_years) {
  print(paste("year:", i))
  df <- d_rdd_bivariate %>%
    filter(year == i)
  rdd <-
    rdrobust::rdrobust(
      y = df$ln_gross_expenditure_pc,
      x = df$inhabs_rel_to_cutoff,
      fuzzy = df$total_seats,
      cluster = df$inhabitants_treshold_factor,
      covs = model.matrix( ~ df$inhabitants_treshold_factor + df$state) # Dropping year FE, obviously
  )
  summary(rdd)
}
```
For each state:
```{r}
# to do: remove eval = F
all_states <- d_rdd_bivariate %>% distinct(state) %>% filter(state != 15) %>% pull() # issues with 15...
for (i in all_states) {
  print(paste("state:", i))
  df <- d_rdd_bivariate %>%
    filter(state == i)
  rdd <-
    rdrobust::rdrobust(
      y = df$ln_gross_expenditure_pc,
      x = df$inhabs_rel_to_cutoff,
      fuzzy = df$total_seats,
      cluster = df$inhabitants_treshold_factor,
      covs = model.matrix( ~ df$inhabitants_treshold_factor + df$year) # Dropping state FE, obviously
  )
  summary(rdd)
}
```


```{r}
rm(list=ls(pattern="^panel_"), all_years, all_states, rdd)
```


### Mass points

Investigating mass points: to do

```{r}
sum(!is.na(data$inhabs_rel_to_cutoff)) # Number of valid observations of running variable
length(unique(data$inhabs_rel_to_cutoff)) # Number of unique values of running variable
sum(!is.na(data$inhabs_rel_to_cutoff)) / length(unique(data$inhabs_rel_to_cutoff)) # 18 observations per value
```

Lee and Card 2008 procedure: Clustering at the respective dicrete values of the running variable

--> RDhonest???




# Concluding Remarks

For references, see the paper.

```{r}
Sys.time() - time
```
