---
author: "Florian Fox"
date: "`r Sys.Date()`"
title: 'Master Thesis: A Causal Test of the Law of 1/n and its Mechanisms -- Analysis: RDD, Normalized Cutoff'
output:
  html_document:
    df_print: paged
    toc: true
    toc_float: true
---

# Load data and packages

```{r Packages}
time <- Sys.time()
library(tidyverse)
library(fixest)
library(rdrobust)
#library(rdmulti)
library(rddensity)
library(rdd) # For the McCrary (2008) test
library(RDHonest)
library(xtable)
library(scales)
library(janitor)
library(latex2exp) # For mathematical notation in ggplot
source("functions/functions.R")
```

```{r Data}
data <-
  readRDS("data/gemeinderatswahlen_alldata.rds") %>%
  mutate(
    year = as.factor(year),
    ags = as.factor(ags)
  )
```

Generating different data sets:

```{r}
# d_bivariate <- data %>%
#   select(ln_gross_expenditure_pc, total_seats, ags, year, state) %>% drop_na()
# d_bivariate_iv <- data %>%
#   select(ln_gross_expenditure_pc, total_seats, ags, year, total_seats_24_y_ago) %>% drop_na()
d_rdd_bivariate <- data %>%
  select(ln_gross_expenditure_pc, total_seats, inhabs_rel_to_cutoff, above_cutoff, inhabitants_treshold_factor, inhabitants_treshold, year, ags, election_year, state, closest, clean_disc_acc_Höhmann, clean_disc_acc_to_my_research) %>%
  drop_na(ln_gross_expenditure_pc, total_seats, inhabs_rel_to_cutoff) %>%
  # Repeat (bandwidth) window calculation for data subsets
  mutate(
    closest = base::rank(abs(inhabs_rel_to_cutoff), ties.method = "last"),
    closest = closest/max(closest),
  )

# d_controls <- data %>%
#   select(ln_gross_expenditure_pc, total_seats, ags, year, inh_tot, pop_over65, unempl_rate, total_area_ha,
#     share_working_age, kreisfreie_stadt, stadt, years_since_last_elec, state) %>%
#   drop_na()
# d_controls_iv <- data %>%
#   select(ln_gross_expenditure_pc, total_seats, ags, year, total_seats_24_y_ago, inh_tot, pop_over65,
#          unempl_rate, total_area_ha, share_working_age, kreisfreie_stadt, stadt,
#          years_since_last_elec) %>%
#   drop_na()
d_rdd <- data %>%
  select(ln_gross_expenditure_pc, total_seats, inhabs_rel_to_cutoff, above_cutoff, closest,
         inhabitants_treshold_factor, year, ags, state,
         inh_tot, pop_over65, unempl_rate, total_area_ha,
         share_working_age, kreisfreie_stadt, stadt, years_since_last_elec) %>%
  drop_na() %>%
  # Repeat (bandwidth) window calculation for data subsets
  mutate(
    closest = base::rank(abs(inhabs_rel_to_cutoff), ties.method = "last"),
    closest = closest/max(closest),
  )
d_ttest <- data %>%
  select(ln_gross_expenditure_pc, inhabs_rel_to_cutoff) %>% drop_na()
```

Additional functions:

```{r}
rdrobust_wrapper <- function(ccluster = NULL, ccovs = NULL) {
  rdrobust::rdrobust(
      y = df$ln_gross_expenditure_pc,
      x = df$inhabs_rel_to_cutoff,
      fuzzy = df$total_seats,
      cluster = ccluster,
      covs = ccovs,
      level = (1-p_value_cutoff)*100
  )
}
```



# Introduction

Sharp RDD mit "intention-to-treat" effect?

Treating all of the cutoffs as one requires a harmonization. This happens according to Egger and Koethenbuerger (2010):

Using the Egger and Koethenbuerger (2010) calculation steps:
$$\tilde{N_i} = ln( N_i/N_d )$$
with $N_i$ as the relevant actual population size and $N_d$ as the respective thresholds.


# t test

The most simple thing to do is a simple t test for differences.

```{r}
# 0.1 around cutoff
d_ttest2 <- d_ttest %>%
  filter(abs(inhabs_rel_to_cutoff) < 0.1) # Choose bandwidth
nrow(d_ttest2) / nrow(data) # Share of observations close to threshold
t.test(log(d_ttest2$ln_gross_expenditure_pc[d_ttest2$inhabs_rel_to_cutoff < 0]),
       log(d_ttest2$ln_gross_expenditure_pc[d_ttest2$inhabs_rel_to_cutoff >= 0]))
# 0.05 around cutoff
d_ttest2 <- d_ttest %>%
  filter(abs(inhabs_rel_to_cutoff) < 0.05) # Choose bandwidth
nrow(d_ttest2) / nrow(data) # Share of observations close to threshold
t.test(log(d_ttest2$ln_gross_expenditure_pc[d_ttest2$inhabs_rel_to_cutoff < 0]),
       log(d_ttest2$ln_gross_expenditure_pc[d_ttest2$inhabs_rel_to_cutoff >= 0]))
# 0.01 around cutoff
d_ttest2 <- d_ttest %>%
  filter(abs(inhabs_rel_to_cutoff) < 0.025) # Choose bandwidth
nrow(d_ttest2) / nrow(data) # Share of observations close to threshold
t.test(log(d_ttest2$ln_gross_expenditure_pc[d_ttest2$inhabs_rel_to_cutoff < 0]),
       log(d_ttest2$ln_gross_expenditure_pc[d_ttest2$inhabs_rel_to_cutoff >= 0]))
```

The results are not really consistent when it comes to statistical significance. The difference between both sides also heavily depends on the bandwidth chosen.
Keep in mind, however, that a t test is not exactly appropriate due to the fuzzy nature of the setting: Whether or not municipalities actually take treatment is not accounted for in this approach.

```{r}
rm(d_ttest2)
```


# Manual IV regression

This is how it is done according to ["The Effect" of Nick Huntington-Klein, chapter 20](https://theeffectbook.net/ch-RegressionDiscontinuity.html):
```{r}
df <- d_rdd_bivariate %>%
  filter(closest <= 0.1) # Choose bandwidth window -- similar to Höhmann (2017)
rdd_bivariate <- fixest::feols(ln_gross_expenditure_pc ~
                                 1  | # controls
                                 inhabitants_treshold_factor + year + ags | # fixed-effect controls
                                 # First stage regression:
                                 inhabs_rel_to_cutoff*total_seats ~ # Instrument our standard RDD...
                                 inhabs_rel_to_cutoff*above_cutoff, # ... with being above the cutoff
                               data = df)
summary(rdd_bivariate, vcov = "hetero")
summary(rdd_bivariate, vcov = "threeway", stage = 1:2)
# For "publication":
rdd_bivariate <- fixest::feols(ln_gross_expenditure_pc ~
                                 1  | # controls
                                 inhabitants_treshold_factor + year + ags | # fixed-effect controls
                                 # First stage regression:
                                 inhabs_rel_to_cutoff*total_seats ~ # Instrument our standard RDD...
                                 inhabs_rel_to_cutoff*above_cutoff, # ... with being above the cutoff
                               vcov = "threeway",
                               data = df)
# Observations below and above:
rdd_bivariate_obs <- d_rdd_bivariate %>% nrow()
rdd_bivariate_below <- df %>% filter(above_cutoff == 0) %>% nrow()
rdd_bivariate_above <- df %>% filter(above_cutoff == 1) %>% nrow()
# More tests:
#fixest::fitstat(rdd, ~ ivf1 + ivwald1 + ivf2 + ivwald2)
rm(df)
```

More simplistic version:
```{r}
df <- d_rdd_bivariate %>%
  filter(closest <= 0.1) # Choose bandwidth window -- similar to Höhmann (2017)
rdd <- fixest::feols(ln_gross_expenditure_pc ~
                     1  | # controls
                     inhabitants_treshold_factor + year + ags | # fixed-effect controls
                     # First stage regression:
                     total_seats ~ # Instrument our standard RDD...
                     above_cutoff, # ... with being above the cutoff
                     data = df)
summary(rdd, vcov = "hetero")
summary(rdd, vcov = "threeway", stage = 1:2)
# More tests:
#fixest::fitstat(rdd, ~ ivf1 + ivwald1 + ivf2 + ivwald2)
rm(df, rdd)
```

```{r, eval = FALSE}
df <- d_rdd_bivariate %>%
  filter(closest <= 0.1) # Choose bandwidth window -- similar to Höhmann (2017)
rdd <- fixest::feols(ln_gross_expenditure_pc ~
                     inhabs_rel_to_cutoff  | # controls
                     inhabitants_treshold_factor + year + ags | # fixed-effect controls
                     # First stage regression:
                     total_seats ~ # Instrument our standard RDD...
                     above_cutoff, # ... with being above the cutoff
                     data = df)
summary(rdd, vcov = "hetero")
summary(rdd, vcov = "threeway", stage = 1:2)
rm(df, rdd)
```

Models without municipality & year FE:

```{r}
df <- d_rdd_bivariate %>%
  filter(closest <= 0.1) # Choose bandwidth window -- similar to Höhmann (2017)
rdd_bivariate_wo_fe <- fixest::feols(ln_gross_expenditure_pc ~
                                       1  | # controls
                                       inhabitants_treshold_factor | # fixed-effect controls
                                       # First stage regression:
                                       inhabs_rel_to_cutoff*total_seats ~ # Instrument our standard RDD...
                                       inhabs_rel_to_cutoff*above_cutoff, # ... with being above the cutoff
                                     vcov = "cluster",
                                     data = df)
summary(rdd_bivariate_wo_fe)
# Observations below and above:
rdd_bivariate_wo_fe_obs <- d_rdd_bivariate %>% nrow()
rdd_bivariate_wo_fe_below <- df %>% filter(above_cutoff == 0) %>% nrow()
rdd_bivariate_wo_fe_above <- df %>% filter(above_cutoff == 1) %>% nrow()
rm(df)
```


Include polynomials:

```{r}
df <- d_rdd_bivariate %>%
  filter(closest <= 0.1) # Choose bandwidth window -- similar to Höhmann (2017)
# Increasing the degree of polynomials
fixest::feols(ln_gross_expenditure_pc ~
                1 | # controls
                inhabitants_treshold_factor + year + ags | # fixed-effect controls
                # First stage regression:
                inhabs_rel_to_cutoff*total_seats ~ # Instrument our standard RDD...
                inhabs_rel_to_cutoff*above_cutoff, # ... with being above the cutoff
              #vcov = "threeway",
              data = df)
fixest::feols(ln_gross_expenditure_pc ~
                1  | # controls
                inhabitants_treshold_factor + year + ags | # fixed-effect controls
                # First stage regression:
                poly(inhabs_rel_to_cutoff, 2)*total_seats ~ # Instrument our standard RDD...
                poly(inhabs_rel_to_cutoff, 2)*above_cutoff, # ... with being above the cutoff
              vcov = "threeway",
              data = df)
fixest::feols(ln_gross_expenditure_pc ~
                1  | # controls
                inhabitants_treshold_factor + year + ags | # fixed-effect controls
                # First stage regression:
                poly(inhabs_rel_to_cutoff, 3)*total_seats ~ # Instrument our standard RDD...
                poly(inhabs_rel_to_cutoff, 3)*above_cutoff, # ... with being above the cutoff
              vcov = "threeway",
              data = df)
fixest::feols(ln_gross_expenditure_pc ~
                1  | # controls
                inhabitants_treshold_factor + year + ags | # fixed-effect controls
                # First stage regression:
                poly(inhabs_rel_to_cutoff, 4)*total_seats ~ # Instrument our standard RDD...
                poly(inhabs_rel_to_cutoff, 4)*above_cutoff, # ... with being above the cutoff
              vcov = "threeway",
              data = df)
fixest::feols(ln_gross_expenditure_pc ~
                1  | # controls
                inhabitants_treshold_factor + year + ags | # fixed-effect controls
                # First stage regression:
                poly(inhabs_rel_to_cutoff, 5)*total_seats ~ # Instrument our standard RDD...
                poly(inhabs_rel_to_cutoff, 5)*above_cutoff, # ... with being above the cutoff
              vcov = "threeway",
              data = df)
fixest::feols(ln_gross_expenditure_pc ~
                1  | # controls
                inhabitants_treshold_factor + year + ags | # fixed-effect controls
                # First stage regression:
                poly(inhabs_rel_to_cutoff, 6)*total_seats ~ # Instrument our standard RDD...
                poly(inhabs_rel_to_cutoff, 6)*above_cutoff, # ... with being above the cutoff
              vcov = "threeway",
              data = df)
rm(df)
```
The results do not differ in their interpretation. The coefficient of interest, `fit_total_seats`, indicates a single-digit decrease of spending at the cutoff but is never statistically significantly different from zero.

Dropping polynomials but adding controls:

```{r}
df <- d_rdd %>%
  filter(closest <= 0.1) # Choose bandwidth window -- similar to Höhmann (2017)
# Continuously adding covariates
fixest::feols(ln_gross_expenditure_pc ~
                csw0(inh_tot, pop_over65, unempl_rate, total_area_ha,
                     share_working_age, kreisfreie_stadt, stadt, years_since_last_elec) | # controls
                inhabitants_treshold_factor + year + ags | # fixed-effect controls
                # First stage regression:
                inhabs_rel_to_cutoff*total_seats ~ # Instrument our standard RDD...
                inhabs_rel_to_cutoff*above_cutoff, # ... with being above the cutoff
              vcov = "threeway",
              data = df)
# Model with covariates
rdd_w_covs <- fixest::feols(ln_gross_expenditure_pc ~
                              inh_tot + pop_over65 + unempl_rate + total_area_ha + share_working_age +
                              kreisfreie_stadt + stadt + years_since_last_elec | # controls
                              inhabitants_treshold_factor + year + ags | # fixed-effect controls
                              # First stage regression:
                              inhabs_rel_to_cutoff*total_seats ~ # Instrument our standard RDD...
                              inhabs_rel_to_cutoff*above_cutoff, # ... with being above the cutoff
                            vcov = "threeway",
                            data = df)
summary(rdd_w_covs)
# Observations below and above:
rdd_w_covs_obs <- d_rdd %>% nrow()
rdd_w_covs_below <- df %>% filter(above_cutoff == 0) %>% nrow()
rdd_w_covs_above <- df %>% filter(above_cutoff == 1) %>% nrow()

rdd_w_covs_wo_fe <- fixest::feols(ln_gross_expenditure_pc ~
                              inh_tot + pop_over65 + unempl_rate + total_area_ha + share_working_age +
                              kreisfreie_stadt + stadt + years_since_last_elec | # controls
                              inhabitants_treshold_factor | # fixed-effect controls
                              # First stage regression:
                              inhabs_rel_to_cutoff*total_seats ~ # Instrument our standard RDD...
                              inhabs_rel_to_cutoff*above_cutoff, # ... with being above the cutoff
                            vcov = "threeway",
                            data = df)
summary(rdd_w_covs_wo_fe)
# Observations below and above:
rdd_w_covs_wo_fe_obs <- d_rdd %>% nrow()
rdd_w_covs_wo_fe_below <- df %>% filter(above_cutoff == 0) %>% nrow()
rdd_w_covs_wo_fe_above <- df %>% filter(above_cutoff == 1) %>% nrow()
rm(df)
```
Interpretation similar to the polynomial case: decrease in the single digits but not significant.

Varying bandwidth:

```{r}
# Baseline
d_rdd_bivariate %>%
  filter(closest <= 0.1) %>% # Choose bandwidth window -- similar to Höhmann (2017)
  fixest::feols(ln_gross_expenditure_pc ~
                  1  | # controls
                  inhabitants_treshold_factor + year + ags | # fixed-effect controls
                  # First stage regression:
                  inhabs_rel_to_cutoff*total_seats ~ # Instrument our standard RDD...
                  inhabs_rel_to_cutoff*above_cutoff, # ... with being above the cutoff
                vcov = "threeway")
# Half the window
d_rdd_bivariate %>%
  filter(closest <= 0.05) %>% # Choose bandwidth window
  fixest::feols(ln_gross_expenditure_pc ~
                  1  | # controls
                  inhabitants_treshold_factor + year + ags | # fixed-effect controls
                  # First stage regression:
                  inhabs_rel_to_cutoff*total_seats ~ # Instrument our standard RDD...
                  inhabs_rel_to_cutoff*above_cutoff, # ... with being above the cutoff
                vcov = "threeway")
# Double the window size
d_rdd_bivariate %>%
  filter(closest <= 0.2) %>% # Choose bandwidth window
  fixest::feols(ln_gross_expenditure_pc ~
                  1  | # controls
                  inhabitants_treshold_factor + year + ags | # fixed-effect controls
                  # First stage regression:
                  inhabs_rel_to_cutoff*total_seats ~ # Instrument our standard RDD...
                  inhabs_rel_to_cutoff*above_cutoff, # ... with being above the cutoff
                vcov = "threeway")
# More tests:
#fixest::fitstat(rdd, ~ ivf1 + ivwald1 + ivf2 + ivwald2)
#rm(df, rdd)
```
Interpretation as before: Non-significant decrease in the single digits.

## Summary

Comparing the two main models:
```{r}
etable(rdd_bivariate_wo_fe, rdd_bivariate, rdd_w_covs_wo_fe, rdd_w_covs)
```

```{r}
etable(#rdd_bivariate, rdd_w_covs,
       rdd_bivariate_wo_fe, rdd_bivariate, rdd_w_covs_wo_fe, rdd_w_covs,
       file = "tables/rdd_iv.tex",
       replace = TRUE,
       # Table settings
       drop = "!Council size",
       dict = c(total_seats = "Council size",
                ln_gross_expenditure_pc = "Ln of gross expenditure p. c."),
       signif.code = c("***"=0.001, "**"=0.01, "*"=0.05, "'"=0.10),
       headers = c("\\acs{wo} covariates \\& \\acs{wo} \\ac{FE}",
                   "\\acs{wo} covariates \\& \\acs{w} \\ac{FE}",
                   "\\acs{w} covariates \\& \\acs{wo} \\ac{FE}",
                   "\\acs{w} covariates \\& \\acs{w} \\ac{FE}"),
       extralines = list(
         "-^Controls" = c("No", "No", "Yes", "Yes"),
         "-_\\acs{SE}" = rep(c("by \\acs{thr}", "by \\acs{mcp}, \\acs{yr} & \\acs{thr}"), 2),
         #"_^Data sample" = c(rep("All data", 3), "\\acs{BY} only")
         "_^Observations above" = c(rdd_bivariate_wo_fe_above, rdd_bivariate_above,
                                    rdd_w_covs_wo_fe_above, rdd_w_covs_above),
         "_^Observations below" = c(rdd_bivariate_wo_fe_below, rdd_bivariate_below,
                                    rdd_w_covs_wo_fe_below, rdd_w_covs_below),
         "_^Observations" = c(rdd_bivariate_wo_fe_obs, rdd_bivariate_obs,
                              rdd_w_covs_wo_fe_obs, rdd_w_covs_obs),
         "_^Window around the threshold" = rep("10%", 4)
         ),
       # LaTeX settings
       title = "Results of the \\acs{IV} \\acs{RDD}",
       label = "tab:rdd_iv",
       notes = paste("\\footnotesize{*Notes:* Results of the \\ac{IV} \\ac{RDD}, in a ten-percent window around the cutoffs.",
                     tex_control_text,
                     "Standard errors clustered at the threshold, year and municipality level in parentheses.",
                     tex_signif_text),
       style.tex = style.tex(
         fixef.suffix = " \\ac{FE}"
       )
       )
```

```{r}
rm(rdd_bivariate, rdd_w_covs)
```




# `rdrobust` package

## Bivariate RDD

Understanding the `rdrobust::rdrobust()` command:

```{r, eval=FALSE}
# to do: remove eval=FALSE
rdd <-
  rdrobust::rdrobust(
    y = d_rdd_bivariate$ln_gross_expenditure_pc,
    x = d_rdd_bivariate$inhabs_rel_to_cutoff,
    fuzzy = d_rdd_bivariate$total_seats
  )
summary(rdd)
rdd <-
  rdrobust::rdrobust(
    y = d_rdd_bivariate$ln_gross_expenditure_pc,
    x = d_rdd_bivariate$inhabs_rel_to_cutoff,
    fuzzy = d_rdd_bivariate$total_seats,
    covs = model.matrix( ~  d_rdd_bivariate$inhabitants_treshold_factor)
  )
summary(rdd)
```

Bivariate RDD without FE:
```{r, rdd_bi_wo_fe}
rdd_bi <-
  rdrobust::rdrobust(
    y = d_rdd_bivariate$ln_gross_expenditure_pc,
    x = d_rdd_bivariate$inhabs_rel_to_cutoff,
    fuzzy = d_rdd_bivariate$total_seats,
    cluster = d_rdd_bivariate$inhabitants_treshold_factor
  )
summary(rdd_bi)
```

Bivariate RDD with one-way FE:

```{r, eval=FALSE}
# to do: remove eval=FALSE
rdd <-
  rdrobust::rdrobust(
    y = d_rdd_bivariate$ln_gross_expenditure_pc,
    x = d_rdd_bivariate$inhabs_rel_to_cutoff,
    fuzzy = d_rdd_bivariate$total_seats,
    cluster = d_rdd_bivariate$inhabitants_treshold_factor,
    covs = model.matrix( ~ d_rdd_bivariate$inhabitants_treshold_factor)
  )
summary(rdd)
rdd <-
  rdrobust::rdrobust(
    y = d_rdd_bivariate$ln_gross_expenditure_pc,
    x = d_rdd_bivariate$inhabs_rel_to_cutoff,
    fuzzy = d_rdd_bivariate$total_seats,
    cluster = d_rdd_bivariate$inhabitants_treshold_factor,
    covs = model.matrix( ~ d_rdd_bivariate$year)
  )
summary(rdd)
rdd <-
  rdrobust::rdrobust(
    y = d_rdd_bivariate$ln_gross_expenditure_pc,
    x = d_rdd_bivariate$inhabs_rel_to_cutoff,
    fuzzy = d_rdd_bivariate$total_seats,
    cluster = d_rdd_bivariate$inhabitants_treshold_factor,
    covs = model.matrix( ~ d_rdd_bivariate$state)
  )
summary(rdd)
```

The threshold FE appear very important: Without them, barely any effect is visible at the first stage. But that makes sense even theoretically as the threshold level indicates on which (sharp) side of the cutoff we are.

Bivariate RDD with threeway FE:
```{r, rdd_bi_fe}
rdd <-
  rdrobust::rdrobust(
    y = d_rdd_bivariate$ln_gross_expenditure_pc,
    x = d_rdd_bivariate$inhabs_rel_to_cutoff,
    fuzzy = d_rdd_bivariate$total_seats,
    covs = model.matrix( ~ d_rdd_bivariate$inhabitants_treshold_factor + d_rdd_bivariate$year + d_rdd_bivariate$state)
  )
summary(rdd)
rdd_bi_fe <-
  rdrobust::rdrobust(
    y = d_rdd_bivariate$ln_gross_expenditure_pc,
    x = d_rdd_bivariate$inhabs_rel_to_cutoff,
    fuzzy = d_rdd_bivariate$total_seats,
    cluster = d_rdd_bivariate$inhabitants_treshold_factor,
    covs = model.matrix( ~ d_rdd_bivariate$inhabitants_treshold_factor + d_rdd_bivariate$year + d_rdd_bivariate$state)
  )
summary(rdd_bi_fe)
```

Using the `rdrobust` package, some things seem either computionally infeasible or impossible by design. Municipality FE take forever to run and are henceforth not considered (but state FE instead).

```{r, eval = FALSE}
# Takes forever to run
rdd_fe_ags <-
  rdrobust::rdrobust(
    y = d_rdd_bivariate$ln_gross_expenditure_pc,
    x = d_rdd_bivariate$inhabs_rel_to_cutoff,
    fuzzy = d_rdd_bivariate$total_seats,
    cluster = d_rdd_bivariate$inhabitants_treshold_factor,
    covs = model.matrix( ~ d_rdd_bivariate$ags)
  )
summary(rdd_fe_ags)
```

Choosing multiple cluster variables appears not possible and that is likely by design as the documentation states: "`cluster` indicates the cluster ID variable" in a singular form:
```{r, eval = FALSE}
rdd_fe <-
  rdrobust::rdrobust(
    y = d_rdd_bivariate$ln_gross_expenditure_pc,
    x = d_rdd_bivariate$inhabs_rel_to_cutoff,
    fuzzy = d_rdd_bivariate$total_seats,
    cluster = model.matrix( ~ d_rdd_bivariate$inhabitants_treshold_factor + d_rdd_bivariate$year)
  )
# or:
rdd_fe <-
  rdrobust::rdrobust(
    y = d_rdd_bivariate$ln_gross_expenditure_pc,
    x = d_rdd_bivariate$inhabs_rel_to_cutoff,
    fuzzy = d_rdd_bivariate$total_seats,
    cluster = d_rdd_bivariate$inhabitants_treshold_factor + d_rdd_bivariate$year
  )
```


## Multivariate RDD

Multivariate RDD without FE:
```{r, rdrobust_multi_fe}
rdd <-
  rdrobust::rdrobust(
    y = d_rdd$ln_gross_expenditure_pc,
    x = d_rdd$inhabs_rel_to_cutoff,
    fuzzy = d_rdd$total_seats,
    covs = d_rdd$inh_tot + d_rdd$pop_over65 + d_rdd$unempl_rate + # controls
      d_rdd$total_area_ha + d_rdd$share_working_age + # controls (cont.)
      model.matrix( ~ d_rdd$kreisfreie_stadt + d_rdd$stadt + d_rdd$years_since_last_elec) # dummy controls
  )
summary(rdd)
rdd_multi <-
  rdrobust::rdrobust(
    y = d_rdd$ln_gross_expenditure_pc,
    x = d_rdd$inhabs_rel_to_cutoff,
    fuzzy = d_rdd$total_seats,
    cluster = d_rdd$inhabitants_treshold_factor,
    covs = d_rdd$inh_tot + d_rdd$pop_over65 + d_rdd$unempl_rate + # controls
      d_rdd$total_area_ha + d_rdd$share_working_age + # controls (cont.)
      model.matrix( ~ d_rdd$kreisfreie_stadt + d_rdd$stadt + d_rdd$years_since_last_elec) # dummy controls
  )
summary(rdd_multi)
```

Multivariate threeway RDD:
```{r, rdd_multi_fe}
rdd <-
  rdrobust::rdrobust(
    y = d_rdd$ln_gross_expenditure_pc,
    x = d_rdd$inhabs_rel_to_cutoff,
    fuzzy = d_rdd$total_seats,
    covs = model.matrix( ~ d_rdd$inhabitants_treshold_factor + d_rdd$year + d_rdd$state + # FE
                           d_rdd$kreisfreie_stadt + d_rdd$stadt + d_rdd$years_since_last_elec) + # dummy controls
      d_rdd$inh_tot + d_rdd$pop_over65 + d_rdd$unempl_rate + # controls
      d_rdd$total_area_ha + d_rdd$share_working_age # controls (cont.)
  )
summary(rdd)
rdd_multi_fe <-
  rdrobust::rdrobust(
    y = d_rdd$ln_gross_expenditure_pc,
    x = d_rdd$inhabs_rel_to_cutoff,
    fuzzy = d_rdd$total_seats,
    cluster = d_rdd$inhabitants_treshold_factor,
    covs = model.matrix( ~ d_rdd$inhabitants_treshold_factor + d_rdd$year + d_rdd$state + # FE
                           d_rdd$kreisfreie_stadt + d_rdd$stadt + d_rdd$years_since_last_elec) + # dummy controls
      d_rdd$inh_tot + d_rdd$pop_over65 + d_rdd$unempl_rate + # controls
      d_rdd$total_area_ha + d_rdd$share_working_age # controls (cont.)
  )
summary(rdd_multi_fe)
```

Comparison of the four main models:
```{r, rdrobust_summary}
summary(rdd_bi)
summary(rdd_bi_fe)
summary(rdd_multi)
summary(rdd_multi_fe)
```

## Manual export to LaTeX

First stage:
```{r}
rdd_tex_export_stage1 <- tibble(
  `Dependent variable:` = c("Model", "", "Running variable", "", "", "", "Controls", "Threshold FE", "Year FE", "State FE"),
  `Council size` = c("RDD w/o covariates", "(1)", round(rdd_bi$tau_T[1], round_decimals), paste0("(", round(rdd_bi$se_T[1], round_decimals), ")"), paste0("[", round(rdd_bi$ci_T[3,1], 3), ", ", round(rdd_bi$ci_T[3,2], 3), "]"), paste0(p_value(rdd_bi$pv_T[3]), assign_stars(rdd_bi$pv_T[3])), rep("No", 4)),
  `2` = c("FE RDD w/o covariates", "(2)", round(rdd_bi_fe$tau_T[1], round_decimals), paste0("(", round(rdd_bi_fe$se_T[1], round_decimals), ")"), paste0("[", round(rdd_bi_fe$ci_T[3,1], 3), ", ", round(rdd_bi_fe$ci_T[3,2], 3), "]"), paste0(p_value(rdd_bi_fe$pv_T[3]), assign_stars(rdd_bi_fe$pv_T[3])), "No", rep("Yes", 3)),
  `3` = c("RDD w/ covariates", "(3)", round(rdd_multi$tau_T[1], round_decimals), paste0("(", round(rdd_multi$se_T[1], round_decimals), ")"), paste0("[", round(rdd_multi$ci_T[3,1], 3), ", ", round(rdd_multi$ci_T[3,2], 3), "]"), paste0(p_value(rdd_multi$pv_T[3]), assign_stars(rdd_multi$pv_T[3])), "Yes", rep("No", 3)),
  `4` = c("FE RDD w/ covariates", "(4)", round(rdd_multi_fe$tau_T[1], round_decimals), paste0("(", round(rdd_multi_fe$se_T[1], round_decimals), ")"), paste0("[", round(rdd_multi_fe$ci_T[3,1], 3), ", ", round(rdd_multi_fe$ci_T[3,2], 3), "]"), paste0(p_value(rdd_multi_fe$pv_T[3]), assign_stars(rdd_multi_fe$pv_T[3])), rep("Yes", 4))
  )
```

Second stage:
```{r}
rdd_tex_export <- tibble(
  `Dependent variable:` = c("Model", "", "Council size", "", "", "", "Controls", "Threshold FE", "Year FE", "State FE", "Observations", "Bandwidth", "Observations below", "Observations above"),
  `Ln of gross expenditure p. c.` = c("RDD w/o covariates", "(1)", round(rdd_bi$Estimate[1], round_decimals), paste0("(", round(rdd_bi$se[1], round_decimals), ")"), paste0("[", round(rdd_bi$ci[3,1], 3), ", ", round(rdd_bi$ci[3,2], 3), "]"), paste0(p_value(rdd_bi$pv[3]), assign_stars(rdd_bi$pv[3])), rep("No", 4), sum(rdd_bi$N), round(rdd_bi$bws[1,1], round_decimals), rdd_bi$N_h[1], rdd_bi$N_h[2]),
  `2` = c("FE RDD w/o covariates", "(2)", round(rdd_bi_fe$Estimate[1], round_decimals), paste0("(", round(rdd_bi_fe$se[1], round_decimals), ")"), paste0("[", round(rdd_bi_fe$ci[3,1], 3), ", ", round(rdd_bi_fe$ci[3,2], 3), "]"), paste0(p_value(rdd_bi_fe$pv[3]), assign_stars(rdd_bi_fe$pv[3])), "No", rep("Yes", 3), sum(rdd_bi_fe$N), round(rdd_bi_fe$bws[1,1], round_decimals), rdd_bi_fe$N_h[1], rdd_bi_fe$N_h[2]),
  `3` = c("RDD w/ covariates", "(3)", round(rdd_multi$Estimate[1], round_decimals), paste0("(", round(rdd_multi$se[1], round_decimals), ")"), paste0("[", round(rdd_multi$ci[3,1], 3), ", ", round(rdd_multi$ci[3,2], 3), "]"), paste0(p_value(rdd_multi$pv[3]), assign_stars(rdd_multi$pv[3])), "Yes", rep("No", 3), sum(rdd_multi$N), round(rdd_multi$bws[1,1], round_decimals), rdd_multi$N_h[1], rdd_multi$N_h[2]),
  `4` = c("FE RDD w/ covariates", "(4)", round(rdd_multi_fe$Estimate[1], round_decimals), paste0("(", round(rdd_multi_fe$se[1], round_decimals), ")"), paste0("[", round(rdd_multi_fe$ci[3,1], 3), ", ", round(rdd_multi_fe$ci[3,2], 3), "]"), paste0(p_value(rdd_multi_fe$pv[3]), assign_stars(rdd_multi_fe$pv[3])), rep("Yes", 4), sum(rdd_multi_fe$N), round(rdd_multi_fe$bws[1,1], round_decimals), rdd_multi_fe$N_h[1], rdd_multi_fe$N_h[2])
  )
```

```{r}
# First-stage export
print(
  xtable::xtable(
    rdd_tex_export_stage1,
    align = "llcccc"
    ),
  file = "tables/rdd_rdrobust_stage1.tex",
  booktabs = TRUE,
  floating = FALSE,
  hline.after = c(-1, -1, 2, 6, nrow(rdd_tex_export_stage1), nrow(rdd_tex_export_stage1)),
  include.rownames = FALSE
)
# Second-stage export
print(
  xtable::xtable(
    rdd_tex_export,
    align = "llcccc"
    ),
  file = "tables/rdd_rdrobust.tex",
  booktabs = TRUE,
  floating = FALSE,
  hline.after = c(-1, -1, 2, 6, 10, nrow(rdd_tex_export), nrow(rdd_tex_export)),
  include.rownames = FALSE
)
```

## Plots

Default plots look strange for some reason:
```{r}
rdrobust::rdplot(y = d_rdd_bivariate$ln_gross_expenditure_pc, x = d_rdd_bivariate$inhabs_rel_to_cutoff)
ggplot(data = d_rdd_bivariate) +
  geom_density(aes(inhabs_rel_to_cutoff))
ggplot(data = d_rdd_bivariate) +
  geom_point(aes(x = inhabs_rel_to_cutoff, y = ln_gross_expenditure_pc))
```

Plotting the estimated model from the previous section:
```{r}
#https://stackoverflow.com/questions/56884210/rdrobust-plotting-graphs-for-local-polynomial-estimation/57614447
rdplot <- rdrobust::rdplot(
  y = d_rdd$ln_gross_expenditure_pc,
  x = d_rdd$inhabs_rel_to_cutoff,
  binselect = "es",
  scale = 5,
  kernel = tolower(rdd_bi_fe$kernel),
  p = rdd_bi_fe$p,
  h = rdd_bi_fe$bws[1],
  covs = model.matrix( ~ d_rdd$inhabitants_treshold_factor + d_rdd$year + d_rdd$state + # FE
                         d_rdd$kreisfreie_stadt + d_rdd$stadt + d_rdd$years_since_last_elec) + # dummy controls
    d_rdd$inh_tot + d_rdd$pop_over65 + d_rdd$unempl_rate + # controls
    d_rdd$total_area_ha + d_rdd$share_working_age, # controls (cont.)
  x.lim = c(-rdd_bi_fe$bws[1], rdd_bi_fe$bws[1]),
  #title = "RD Plot - Senate Elections Data",
  x.label = "Population",
  y.label = "Ln of gross expenditure p. c.",
  ci = 95)
rdplot
```

Manual plots:

`rdd_bi_fe` model: Jump at the cutoff (`r rdd_bi_fe$beta_p_r[1] - rdd_bi_fe$beta_p_l[1]`) somehow not equivalent to jump displayed in the output (e. g. in `summary()`: `r rdd_bi_fe$coef[1]`), especially given that the latter is *positive*...
```{r}
# Following Huntington-Klein, https://theeffectbook.net/ch-RegressionDiscontinuity.html
d_rdd_bivariate %>%
  mutate(inhabs_bins = cut(
    inhabs_rel_to_cutoff,
    breaks = seq(
      -rdd_bi_fe$bws[1, 1]*2,
      rdd_bi_fe$bws[1, 2]*2,
      (rdd_bi_fe$bws[1, 1] + rdd_bi_fe$bws[1, 2]) / 20 # Must break at 0
    )
  )) %>% 
    group_by(inhabs_bins) %>%
    summarize(ln_gross_expenditure_pc = mean(ln_gross_expenditure_pc),
              inhabs_mean = mean(inhabs_rel_to_cutoff)) %>%
  # "Taking the mean of running variable lets us plot data roughly at the bin midpoints"
  ggplot() + 
  geom_point(aes(x = inhabs_mean, y = ln_gross_expenditure_pc)) +
  geom_vline(aes(xintercept = 0), linetype = "dotted") +
  geom_segment(aes(x = -rdd_bi_fe$bws[1, 1],
                   y = rdd_bi_fe$beta_p_l[1]+rdd_bi_fe$beta_p_l[2]*(-rdd_bi_fe$bws[1, 1]),
                   xend = 0, yend = rdd_bi_fe$beta_p_l[1])) +
  geom_segment(aes(x = 0,
                   yend = rdd_bi_fe$beta_p_r[1]+rdd_bi_fe$beta_p_r[2]*(rdd_bi_fe$bws[1, 1]),
                   xend = rdd_bi_fe$bws[1, 1],
                   y = rdd_bi_fe$beta_p_r[1])) +
  labs(x = "Running variable", y = "Ln of gross expenditure p. c.")
```

Hence, use `rdd_bi` model:
```{r}
binned <- d_rdd_bivariate %>%
  mutate(inhabs_bins = cut(
    inhabs_rel_to_cutoff,
    breaks = seq(
      -rdd_bi$bws[1, 1]*2,
      rdd_bi$bws[1, 2]*2,
      (rdd_bi$bws[1, 1] + rdd_bi$bws[1, 2]) / 20 # Must break at 0
    )
  )) %>% 
    group_by(inhabs_bins) %>%
    summarize(ln_gross_expenditure_pc = mean(ln_gross_expenditure_pc),
              inhabs_mean = mean(inhabs_rel_to_cutoff),
              n = n()) %>%
  drop_na(inhabs_bins)
ggplot(data = binned) + 
  geom_point(aes(x = inhabs_mean, y = ln_gross_expenditure_pc, size = n)) +
  scale_size_continuous(range = c(1, 2)) + # Reduced overall point size
  geom_vline(aes(xintercept = 0), linetype = "dotted") +
  geom_segment(aes(x = -rdd_bi$bws[1, 1],
                   y = rdd_bi$beta_p_l[1]+rdd_bi$beta_p_l[2]*(-rdd_bi$bws[1, 1]),
                   xend = 0, yend = rdd_bi$beta_p_l[1])) +
  geom_segment(aes(x = 0,
                   yend = rdd_bi$beta_p_r[1]+rdd_bi$beta_p_r[2]*(rdd_bi$bws[1, 1]),
                   xend = rdd_bi$bws[1, 1],
                   y = rdd_bi$beta_p_r[1])) +
  labs(x = "Running variable", y = "Ln of gross expenditure per capita")
# to do in ggplot: add big mark to ggplot legend
summary(binned$n)
sum(binned$n)
#rm(binned)
ggsave(filename = "plots/rdd_plot.pdf", width = 6, height = 6*9/16)
```




## Robustness Checks

The RDD FE model without covariates will be regarded as the baseline model. Hence, write a wrapper function to ease the use of the model:

```{r, robustness_function}
rdrobust_fe_model <- function(cc = NULL, pp = NULL, qq = NULL, hh = NULL, bb = NULL, kkernel = "tri", bbwselect = "mserd", vvce = "nn") {
  rdrobust::rdrobust(
    y = d_rdd_bivariate$ln_gross_expenditure_pc,
    x = d_rdd_bivariate$inhabs_rel_to_cutoff,
    c = cc,
    fuzzy = d_rdd_bivariate$total_seats,
    cluster = d_rdd_bivariate$inhabitants_treshold_factor,
    covs = model.matrix( ~ d_rdd_bivariate$inhabitants_treshold_factor + d_rdd_bivariate$year + d_rdd_bivariate$state),
    # set parameters to run for robustness tests; set them to rdrobust defaults
    p = pp,
    q = qq,
    h = hh,
    b = bb,
    kernel = kkernel,
    bwselect = bbwselect,
    vce = vvce
  )
}
```
```{r, eval=FALSE}
# to do: remove eval=FALSE
rdd <- rdrobust_fe_model()
summary(rdd) # equal to rdd_bi_fe model
```


### Different RDD specifications

Vary p, the local polynomial. Conclusions remain. On the first stage, council size jumps by a value somewhat larger than 1 at the threshold (highly statistically significant). The second stage, however, remains insignificant, with some p values around 0.2, the others are (in part way) larger. The coefficient is always slightly positive.
```{r, eval=FALSE}
# to do: remove eval=FALSE
rdd_vary_p_df <-
  tibble(polynomial = "", point_estimate = "", se = "", se_robust = "",
         ci_lower = "", ci_upper = "", p = "", bw = "", obs_below = "", obs_above = "") %>%
  mutate(across(everything(), as.numeric))
for (vary_p in 0:6) {
  print(paste("polynomial of degree", vary_p))
  rdd <- rdrobust_fe_model(pp = vary_p)
  summary(rdd)
  rdd_vary_p_df <- rdd_vary_p_df %>%
    dplyr::add_row(
      polynomial = vary_p,
      point_estimate = rdd$coef[1],
      se = rdd$se[1],
      se_robust = rdd$se[3],
      ci_lower = rdd$ci[3,1],
      ci_upper = rdd$ci[3,2],
      p = rdd$pv[3],
      bw = rdd$bws[1,1],
      obs_below = rdd$N_h[1],
      obs_above = rdd$N_h[2]
  )
}
rdd_vary_p_df <- rdd_vary_p_df %>% drop_na()
save(rdd_vary_p_df, file = "tables_robustness_checks/rdd_vary_p_df.Rdata")
```
```{r}
load(file = "tables_robustness_checks/rdd_vary_p_df.Rdata")
rdd_vary_p_df
```

Vary q, the "local-polynomial used to construct the bias correction". Conclusions similar to varying p: Highly significant first stage across all `q`s, non-significant second stage (p values as low as 0.2) and positive around 1%.
```{r, rdd_vary_q, eval=FALSE}
# to do: remove eval=FALSE
rdd_vary_q_df <-
  tibble(polynomial = "", point_estimate = "", se = "", se_robust = "",
         ci_lower = "", ci_upper = "", p = "", bw = "", obs_below = "", obs_above = "") %>%
  mutate(across(everything(), as.numeric))
for (vary_q in 2:6) {
  print(paste("polynomial of degree", vary_q))
  rdd <- rdrobust_fe_model(qq = vary_q)
  summary(rdd)
  rdd_vary_q_df <- rdd_vary_q_df %>%
    dplyr::add_row(
      polynomial = vary_q,
      point_estimate = rdd$coef[1],
      se = rdd$se[1],
      se_robust = rdd$se[3],
      ci_lower = rdd$ci[3,1],
      ci_upper = rdd$ci[3,2],
      p = rdd$pv[3],
      bw = rdd$bws[1,1],
      obs_below = rdd$N_h[1],
      obs_above = rdd$N_h[2]
  )
}
rdd_vary_q_df <- rdd_vary_q_df %>% drop_na()
save(rdd_vary_q_df, file = "tables_robustness_checks/rdd_vary_q_df.Rdata")
```
```{r}
load(file = "tables_robustness_checks/rdd_vary_q_df.Rdata")
rdd_vary_q_df
```

Vary kernel: No large differences between kernels.
```{r, rdd_vary_kernel, eval=FALSE}
# to do: remove eval=FALSE
rdd_vary_kernel_df <-
  tibble(kernel = "", point_estimate = "", se = "", se_robust = "",
         ci_lower = "", ci_upper = "", p = "", bw = "", obs_below = "", obs_above = "") %>%
  mutate(across(2:last_col(), as.numeric))
for (vary_kernel in c("tri", "epa", "uni")) {
  print(paste("kernel:", vary_kernel))
  rdd <- rdrobust_fe_model(kkernel = vary_kernel)
  summary(rdd)
  rdd_vary_kernel_df <- rdd_vary_kernel_df %>%
    dplyr::add_row(
      kernel = vary_kernel,
      point_estimate = rdd$coef[1],
      se = rdd$se[1],
      se_robust = rdd$se[3],
      ci_lower = rdd$ci[3,1],
      ci_upper = rdd$ci[3,2],
      p = rdd$pv[3],
      bw = rdd$bws[1,1],
      obs_below = rdd$N_h[1],
      obs_above = rdd$N_h[2]
  )
}
rdd_vary_kernel_df <- rdd_vary_kernel_df %>% drop_na()
save(rdd_vary_kernel_df, file = "tables_robustness_checks/rdd_vary_kernel_df.Rdata")
```
```{r}
load(file = "tables_robustness_checks/rdd_vary_kernel_df.Rdata")
rdd_vary_kernel_df
```

Vary variance-covariance matrix: The `hc` vce appear extremely similar. Conclusions, however, are not altered.
```{r, rdd_vary_vcov, eval=FALSE}
# to do: remove eval=FALSE
rdd_vary_vcov_df <-
  tibble(vcov = "", point_estimate = "", se = "", se_robust = "",
         ci_lower = "", ci_upper = "", p = "", bw = "", obs_below = "", obs_above = "") %>%
  mutate(across(2:last_col(), as.numeric))
for (vary_vcov in c("nn", "hc0", "hc1", "hc2", "hc3")) {
  print(paste("vce:", vary_vcov))
  rdd <- rdrobust_fe_model(vvce = vary_vcov)
  summary(rdd)
  rdd_vary_vcov_df <- rdd_vary_vcov_df %>%
    dplyr::add_row(
      vcov = vary_vcov,
      point_estimate = rdd$coef[1],
      se = rdd$se[1],
      se_robust = rdd$se[3],
      ci_lower = rdd$ci[3,1],
      ci_upper = rdd$ci[3,2],
      p = rdd$pv[3],
      bw = rdd$bws[1,1],
      obs_below = rdd$N_h[1],
      obs_above = rdd$N_h[2]
  )
}
rdd_vary_vcov_df <- rdd_vary_vcov_df %>% drop_na()
save(rdd_vary_vcov_df, file = "tables_robustness_checks/rdd_vary_vcov_df.Rdata")
```
```{r}
load(file = "tables_robustness_checks/rdd_vary_vcov_df.Rdata")
rdd_vary_vcov_df
```

### Sensitivity analysis

#### Ad-hoc chosen bandwidths

Vary the bandwidths `h` and `b`, manually set those instead of using a data-driven algorithm. If `h` is manually set to a certain value, the function sets `b` to the very same value. However, since the two are typically not in the same ballpark when calculated automatically (i. e. in a data-driven way), I will run the two loops separately with different values.
Conclusion: In these cases, varying the parameters does matter for the result (this is not the case with `p` and `q`). The larger the bandwidth, the larger the first-stage coefficient. In addition, the significance level of the second stage coefficient increases (the p value decreases) in the bandwidth. The value of the coefficient of interest is steady at a bit more than 1%. Note, however, that the last models include more than half of the sample size in the calculation, potentially invalidating the research design.
```{r, rdd_bw_manual, eval=FALSE}
# to do: remove eval=FALSE
rdd_vary_h_df <-
  tibble(h = "", point_estimate = "", se = "", se_robust = "",
         ci_lower = "", ci_upper = "", p = "", bw = "", obs_below = "", obs_above = "") %>%
  mutate(across(everything(), as.numeric))
for (vary_h in seq(0.02, 0.2, 0.03)) {
  print(paste("h = ", vary_h))
  rdd <- rdrobust_fe_model(hh = vary_h)
  summary(rdd)
  rdd_vary_h_df <- rdd_vary_h_df %>%
    dplyr::add_row(
      h = vary_h,
      point_estimate = rdd$coef[1],
      se = rdd$se[1],
      se_robust = rdd$se[3],
      ci_lower = rdd$ci[3,1],
      ci_upper = rdd$ci[3,2],
      p = rdd$pv[3],
      bw = rdd$bws[1,1],
      obs_below = rdd$N_h[1],
      obs_above = rdd$N_h[2]
  )
}
rdd_vary_h_df <- rdd_vary_h_df %>% drop_na()
save(rdd_vary_h_df, file = "tables_robustness_checks/rdd_vary_h_df.Rdata")
```
```{r}
load(file = "tables_robustness_checks/rdd_vary_h_df.Rdata")
rdd_vary_h_df
```

Apparently, the bandwidth `b` cannot be set manually. Perhaps change `rho` parameter or set `b` manually and `b` via the `bwselect()` function.
```{r, eval=FALSE}
for (vary_b in seq(0.15, 0.45, 0.075)) {
  print(paste("RDD with bandwidth b =", vary_b))
  rdd <- rdrobust_fe_model(bb = vary_b)
  summary(rdd)
}
```

Window bandwidth selection (similar to Höhmann, 2017; i. e. do not use automatic bandwidth selection algorithm but all observations within the window chosen). For large window values (>0.05), the conclusions drawn remain unchanged. For window values <=0.05, however, the coefficients for council size at the second stage are significant. Nevertheless, the sign switches: For low window values, there is a negative effect (-6% and -3%, respectively), for higher window cutoffs, there is a weakly positive effect. Regarding the sample size, note that even the smallest window yields a sample size of more than 1000 observations.
```{r, rdd_window, eval=FALSE}
# to do: remove eval=FALSE
rdd_vary_window <-
  tibble(window = "", point_estimate = "", se = "", se_robust = "",
         ci_lower = "", ci_upper = "", p = "", bw = "", obs_below = "", obs_above = "") %>%
  mutate(across(everything(), as.numeric))
for (vary_window in seq(0.01, 0.25, 0.01)) {
  print(paste("RDD with window: ", vary_window))
  df <- d_rdd_bivariate %>%
    filter(closest <= vary_window)
  str(vary_window)
  rdd <-
    rdrobust::rdrobust(
      y = df$ln_gross_expenditure_pc,
      x = df$inhabs_rel_to_cutoff,
      fuzzy = df$total_seats,
      cluster = df$inhabitants_treshold_factor,
      covs = model.matrix( ~ df$inhabitants_treshold_factor + df$year + df$state),
      h = 10 # 10 is larger than any absolute value of the running variable => use all observations
  )
  summary(rdd)
  rdd_vary_window <- rdd_vary_window %>%
    dplyr::add_row(
      window = vary_window,
      point_estimate = rdd$coef[1],
      se = rdd$se[1],
      se_robust = rdd$se[3],
      ci_lower = rdd$ci[3,1],
      ci_upper = rdd$ci[3,2],
      p = rdd$pv[3],
      bw = rdd$bws[1,1],
      obs_below = rdd$N_h[1],
      obs_above = rdd$N_h[2]
  )
}
rdd_vary_window <- rdd_vary_window %>% drop_na()
save(rdd_vary_window, file = "tables_robustness_checks/rdd_vary_window.Rdata")
```
```{r}
load(file = "tables_robustness_checks/rdd_vary_window.Rdata")
rdd_vary_window
```
Plot windows. Coefficients and CIs need not overlap because standard coefficients are paired with robust-corrected CIs.

```{r, rdd_window_plot}
ggplot2::ggplot(data = rdd_vary_window, aes(x = window, y = point_estimate)) +
  geom_line(size = 1.5, color = ifelse(rdd_vary_window$p <= 0.05, 2, 1)) +
  geom_ribbon(aes(ymin = ci_lower, ymax = ci_upper), alpha = 0.3) +
  geom_hline(aes(yintercept = 0), linetype = "dotted") +
  scale_x_continuous(labels = scales::percent) +
  scale_y_continuous(labels = scales::percent) +
  labs(x = "Window around the threshold", y = y_lab_RDD)
ggplot2::ggplot(data = rdd_vary_window, aes(x = window, y = point_estimate)) +
  geom_point(size = 1.5, color = ifelse(rdd_vary_window$p <= 0.05, 2, 1)) +
  geom_errorbar(aes(ymin = ci_lower, ymax = ci_upper),
                color = ifelse(rdd_vary_window$p <= 0.05, 2, 1),
                linetype = ifelse(rdd_vary_window$p <= 0.05, 2, 1),
                width = 0.005) +
  geom_hline(aes(yintercept = 0), linetype = "dotted") +
  scale_x_continuous(labels = scales::percent) +
  scale_y_continuous(labels = scales::percent) +
  labs(x = "Window around the threshold", y = y_lab_RDD)
ggsave(filename = "plots/rdrobust_bw_window.pdf", width = 6, height = 6*9/16)
```

#### `rdbwselect` automatic bandwidth selection procedures

Different `rdbwselect` options: Most bandwidth selection algorithms yield similar results to the default one. One or two, however, gain statistical significance for the regressor of interest by virtue of a larger bandwidth.
```{r, eval=FALSE}
# to do: remove eval=FALSE
rdd_vary_bwselect <-
  tibble(bw_sel_algo = "", point_estimate = "", se = "", se_robust = "",
         ci_lower = "", ci_upper = "", p = "", bw = "", obs_below = "", obs_above = "") %>%
  mutate(across(2:last_col(), as.numeric))
for (vary_bwselect in c("mserd", "msetwo", "msesum", "msecomb1", "msecomb2", "cerrd", "certwo", "cersum", "cercomb1", "cercomb2")) {
  print(paste("Bandwidth selection algorithm:", vary_bwselect))
  rdd <- rdrobust_fe_model(bbwselect = vary_bwselect)
  #summary(rdd)
  rdd_vary_bwselect <- rdd_vary_bwselect %>%
    dplyr::add_row(
      bw_sel_algo = vary_bwselect,
      point_estimate = rdd$coef[1],
      se = rdd$se[1],
      se_robust = rdd$se[3],
      ci_lower = rdd$ci[3,1],
      ci_upper = rdd$ci[3,2],
      p = rdd$pv[3],
      bw = rdd$bws[1,1],
      obs_below = rdd$N_h[1],
      obs_above = rdd$N_h[2]
  )
}
rdd_vary_bwselect <- rdd_vary_bwselect %>% drop_na()
save(rdd_vary_bwselect, file = "tables_robustness_checks/rdd_vary_bwselect")
```
```{r}
load(file = "tables_robustness_checks/rdd_vary_bwselect")
rdd_vary_bwselect
```

Plot bandwidth selection algorithms. Coefficients and CIs need not overlap because standard coefficients are paired with robust-corrected CIs.
Note: In general may be a good idea, but hard to explain all bandwidth selectors in the paper just for the purpose of this plot...
```{r, rdd_window_plot2}
ggplot2::ggplot(data = rdd_vary_bwselect, aes(x = bw_sel_algo, y = point_estimate)) +
  geom_point(size = 1.5, color = ifelse(rdd_vary_bwselect$p <= 0.05, 2, 1)) +
  geom_errorbar(aes(ymin = ci_lower, ymax = ci_upper),
                color = ifelse(rdd_vary_bwselect$p <= 0.05, 2, 1),
                linetype = ifelse(rdd_vary_bwselect$p <= 0.05, 2, 1),
                width = 0.5) +
  geom_hline(aes(yintercept = 0), linetype = "dotted") +
  scale_y_continuous(labels = scales::percent) +
  labs(x = "Bandwidth selection procedure", y = y_lab_RDD)
```

```{r}
rm(rdd)
```


### Dropping confounded thresholds

Dropping confounded thresholds as determined by my own legal research: The conclusions are quite similar for both "Höhmann's" and "my" thresholds -- the effect of council size is small and positive (in the really small single-digits) but nonsignificant for both counfounded as well as nonconfounded thresholds.

#### "My" research variable `clean_disc_acc_to_my_research`

... is first up.

Subsample method:

```{r, eval=FALSE}
# to do: remove eval=FALSE
data_subset <- data %>% # prepare data set used for analysis
  select(ln_gross_expenditure_pc, inhabs_rel_to_cutoff, total_seats, inhabitants_treshold_factor, state, year, clean_disc_acc_to_my_research) %>%
  drop_na()
all_values <- data_subset %>% distinct(clean_disc_acc_to_my_research) %>% pull() # vector of values
rdd_vary_clean_disc1 <- # prepare data set to store the results
  tibble(value = "", point_estimate = "", se = "", se_robust = "",
         ci_lower = "", ci_upper = "", p = "", bw = "", obs_below = "", obs_above = "") %>%
  mutate(across(everything(), as.numeric))
for (i in all_values) {
  print(paste("clean_disc_acc_to_my_research:", i))
  df <- data_subset %>%
    filter(clean_disc_acc_to_my_research == i)
  rdd <-
    rdrobust_wrapper(
      ccluster = df$inhabitants_treshold_factor,
      ccovs = model.matrix( ~ df$inhabitants_treshold_factor + df$state + df$year) # FE
  )
  #summary(rdd)
  rdd_vary_clean_disc1 <- rdd_vary_clean_disc1 %>%
    dplyr::add_row(
      value = i,
      point_estimate = rdd$coef[1],
      se = rdd$se[1],
      se_robust = rdd$se[3],
      ci_lower = rdd$ci[3,1],
      ci_upper = rdd$ci[3,2],
      p = rdd$pv[3],
      bw = rdd$bws[1,1],
      obs_below = rdd$N_h[1],
      obs_above = rdd$N_h[2]
  )
}
rdd_vary_clean_disc1 <- rdd_vary_clean_disc1 %>% drop_na()
save(rdd_vary_clean_disc1, file = "tables_robustness_checks/rdd_vary_clean_disc1.Rdata")
rm(all_values, data_subset, df, i, rdd)
```
```{r}
load(file = "tables_robustness_checks/rdd_vary_clean_disc1.Rdata")
rdd_vary_clean_disc1
```

```{r}
ggplot2::ggplot(data = rdd_vary_clean_disc1, aes(x = value, y = point_estimate)) +
  geom_point(size = 1.5, color = ifelse(rdd_vary_clean_disc1$p <= p_value_cutoff, 2, 1)) +
  geom_errorbar(aes(ymin = ci_lower, ymax = ci_upper),
                color = ifelse(rdd_vary_clean_disc1$p <= p_value_cutoff, 2, 1),
                linetype = ifelse(rdd_vary_clean_disc1$p <= p_value_cutoff, 2, 1),
                width = 0.5) +
  geom_hline(aes(yintercept = 0), linetype = "dotted") +
  scale_y_continuous(labels = scales::percent) +
  labs(y = y_lab_RDD)
```

Looks like there is no difference.


Interaction-term method using an IV approach:

```{r}
df <- data %>%
  filter(closest <= 0.1)
rdd_conf_1 <- fixest::feols(ln_gross_expenditure_pc ~
                       1  | # controls
                       inhabitants_treshold_factor + state + year | # fixed-effect controls
                       # First stage regression:
                       inhabs_rel_to_cutoff*total_seats*clean_disc_acc_to_my_research ~
                       inhabs_rel_to_cutoff*above_cutoff*clean_disc_acc_to_my_research,
                     vcov = "threeway",
                     data = df)
# Observations below and above:
rdd_conf_1_obs <- d_rdd_bivariate %>% nrow()
rdd_conf_1_below <- df %>% filter(above_cutoff == 0) %>% nrow()
rdd_conf_1_above <- df %>% filter(above_cutoff == 1) %>% nrow()
summary(rdd_conf_1)
rm(df)
```



#### Höhmann's (2017) research variable `clean_disc_acc_Höhmann`

Next up are the reevaluation of what Höhmann (2017) determines as confounded thresholds.

Subsample method:

```{r, eval=FALSE}
# to do: remove eval=FALSE
data_subset <- data %>% # prepare data set used for analysis
  select(ln_gross_expenditure_pc, inhabs_rel_to_cutoff, total_seats, inhabitants_treshold_factor, state, year, clean_disc_acc_Höhmann) %>%
  drop_na()
all_values <- data_subset %>% distinct(clean_disc_acc_Höhmann) %>% pull() # vector of values
rdd_vary_clean_disc2 <- # prepare data set to store the results
  tibble(value = "", point_estimate = "", se = "", se_robust = "",
         ci_lower = "", ci_upper = "", p = "", bw = "", obs_below = "", obs_above = "") %>%
  mutate(across(everything(), as.numeric))
for (i in all_values) {
  print(paste("clean_disc_acc_Höhmann:", i))
  df <- data_subset %>%
    filter(clean_disc_acc_Höhmann == i)
  rdd <-
    rdrobust_wrapper(
      ccluster = df$inhabitants_treshold_factor,
      ccovs = model.matrix( ~ df$inhabitants_treshold_factor + df$state + df$year) # FE
  )
  #summary(rdd)
  rdd_vary_clean_disc2 <- rdd_vary_clean_disc2 %>%
    dplyr::add_row(
      value = i,
      point_estimate = rdd$coef[1],
      se = rdd$se[1],
      se_robust = rdd$se[3],
      ci_lower = rdd$ci[3,1],
      ci_upper = rdd$ci[3,2],
      p = rdd$pv[3],
      bw = rdd$bws[1,1],
      obs_below = rdd$N_h[1],
      obs_above = rdd$N_h[2]
  )
}
rdd_vary_clean_disc2 <- rdd_vary_clean_disc2 %>% drop_na()
save(rdd_vary_clean_disc2, file = "tables_robustness_checks/rdd_vary_clean_disc2.Rdata")
rm(all_values, data_subset, df, i, rdd)
```
```{r}
load(file = "tables_robustness_checks/rdd_vary_clean_disc2.Rdata")
rdd_vary_clean_disc2
```

```{r}
ggplot2::ggplot(data = rdd_vary_clean_disc2, aes(x = value, y = point_estimate)) +
  geom_point(size = 1.5, color = ifelse(rdd_vary_clean_disc2$p <= p_value_cutoff, 2, 1)) +
  geom_errorbar(aes(ymin = ci_lower, ymax = ci_upper),
                color = ifelse(rdd_vary_clean_disc2$p <= p_value_cutoff, 2, 1),
                linetype = ifelse(rdd_vary_clean_disc2$p <= p_value_cutoff, 2, 1),
                width = 0.5) +
  geom_hline(aes(yintercept = 0), linetype = "dotted") +
  scale_y_continuous(labels = scales::percent) +
  labs(y = y_lab_RDD)
```

Looks like there is no difference, again.

Interaction-term method using an IV approach:

```{r}
df <- data %>%
  filter(closest <= 0.1)
rdd_conf_2 <- fixest::feols(ln_gross_expenditure_pc ~
                       1  | # controls
                       inhabitants_treshold_factor + state + year | # fixed-effect controls
                       # First stage regression:
                       inhabs_rel_to_cutoff*total_seats*clean_disc_acc_Höhmann ~
                       inhabs_rel_to_cutoff*above_cutoff*clean_disc_acc_Höhmann,
                     vcov = "threeway",
                     data = df)
# Observations below and above:
rdd_conf_2_obs <- d_rdd_bivariate %>% nrow()
rdd_conf_2_below <- df %>% filter(above_cutoff == 0) %>% nrow()
rdd_conf_2_above <- df %>% filter(above_cutoff == 1) %>% nrow()
summary(rdd_conf_2)
rdd_conf_2$coefficients[2] + rdd_conf_2$coefficients[6]
rm(df)
```

Looks like there is a difference after all.

```{r}
etable(rdd_conf_1, rdd_conf_2,
       file = "tables/rdd_conf_thresholds.tex",
       replace = TRUE,
       # Table settings
       keep = c("Council size baseline for nonconfounded thresholds",
                "Additional TE for confounded thresholds"),
       dict = c(total_seats = "Council size baseline for nonconfounded thresholds",
                `total_seats:clean_disc_acc_to_my_research` = "Additional TE for confounded thresholds",
                `total_seats:clean_disc_acc_Höhmann` = "Additional TE for confounded thresholds",
                ln_gross_expenditure_pc = "Ln of gross expenditure p. c."),
       drop.section = "fixef",
       signif.code = c("***"=0.001, "**"=0.01, "*"=0.05, "'"=0.10),
       headers = c("Confounded thresholds based on my research",
                   "Confounded thresholds based on \\citeauthor{Hohmann.2017}'s \\parencite*{Hohmann.2017} research"),
        extralines = list(
       #   "-^Controls" = c("No", "Yes")#,
       #   #"-_\\acs{SE}" = rep("by threshold, \\acs{yr} & \\acs{mcp}", 2),
       #   #"_^Data sample" = c(rep("All data", 3), "\\acs{BY} only")
          "_^Observations above" = c(rdd_conf_1_above, rdd_conf_2_above),
         "_^Observations below" = c(rdd_conf_1_below, rdd_conf_2_below),
         "_^Observations" = c(rdd_conf_1_obs, rdd_conf_2_obs),
         "_^Window around the threshold" = rep("10%", 2)

          ),
       # LaTeX settings
       title = "Results of the interacted \\acs{IV} \\acs{RDD}s to investigate (non)confounded thresholds",
       label = "tab:rdd_conf_thresholds",
       notes = paste("\\footnotesize{*Notes:* Results of the \\ac{IV} \\ac{RDD}, in a ten-percent window around the cutoffs. No control variables but threshold, state, and year \\ac{FE}. Standard errors clustered at the threshold, year and municipality level in parentheses.",
                     tex_signif_text)#,
       # style.tex = style.tex(
       #   fixef.suffix = " \\ac{FE}"
       # )
       )
```



### Placebo thresholds

#### Overall sample

First attempt

```{r, rdrobust_place1, eval=FALSE}
# to do: remove eval=FALSE
rdd_placebo <-
  tibble(placebo_c = "", point_estimate = "", se = "", se_robust = "",
         ci_lower = "", ci_upper = "", p = "", bw = "", obs_below = "", obs_above = "") %>%
  mutate(across(everything(), as.numeric))
vector <- seq(from = -(2+2/3), to = 2/3, by = 1/6) # Choose vector of arbitrary placebo cutoffs
#vector <- vector[!vector %in% (-2-1/3)]
vector <- vector[-c(3, 21)] # Drop cutoffs that yield errors
for (i in vector) {
  print(paste("Cutoff at:", i))
  rdd <- rdrobust_fe_model(cc = i)
  #summary(rdd)
  rdd_placebo <- rdd_placebo %>%
    dplyr::add_row(
      placebo_c = i,
      point_estimate = rdd$coef[1],
      se = rdd$se[1],
      se_robust = rdd$se[3],
      ci_lower = rdd$ci[3,1],
      ci_upper = rdd$ci[3,2],
      p = rdd$pv[3],
      bw = rdd$bws[1,1],
      obs_below = rdd$N_h[1],
      obs_above = rdd$N_h[2]
  )
}
rdd_placebo <- rdd_placebo %>% drop_na()
rm(vector)
save(rdd_placebo, file = "tables_robustness_checks/rdd_placebo_1.Rdata")
```
```{r}
load(file = "tables_robustness_checks/rdd_placebo_1.Rdata")
rdd_placebo
```
Visualization of placebo cutoffs:
```{r, rdrobust_placebo_viz1}
df <- rdd_placebo %>%
  #tidyr::drop_na() %>%
  filter(abs(ci_upper) < 100 | abs(ci_lower) < 100) %>%
  mutate(effective_n = trimws(format(sum(obs_below, obs_above), big.mark = ",") ) ) # add big mark
ggplot2::ggplot(df) +
  geom_point(aes(x = placebo_c, y = point_estimate), size = 1.5, colour = ifelse(df$p <= 0.05, 2, 1)) +
  geom_errorbar(aes(x = placebo_c, ymin = ci_lower, ymax = ci_upper),
                colour = ifelse(df$p <= 0.05, 2, 1),
                linetype = ifelse(df$p <= 0.05, 2, 1)) +
  geom_text(aes(x = placebo_c, y = ci_lower, label = effective_n),
            colour = ifelse(df$p <= 0.05, 2, 1), vjust = 1, size = 2.3, check_overlap = TRUE) +
  geom_hline(aes(yintercept = 0), linetype = "dotted") +
  geom_vline(aes(xintercept = 0), linetype = "dotted") +
  scale_y_continuous(labels = scales::percent) +
  labs(x = "Cutoff of the running variable", y = y_lab_RDD)
ggsave(filename = "plots/rdrobust_placebo_wide.pdf", width = 6, height = 6*9/16)
rm(df)
```

Second attempt -- main approach: Regular cutoffs within the inter-quartile range.

```{r, rdrobust_place2, eval=FALSE}
# to do: remove eval=FALSE
rdd_placebo <-
  tibble(placebo_c = "", point_estimate = "", se = "", se_robust = "",
         ci_lower = "", ci_upper = "", p = "", bw = "", obs_below = "", obs_above = "") %>%
  mutate(across(everything(), as.numeric))
vector <- seq(from = (-0.15), to = (0.18), by = 0.03) # Choose vector of arbitrary placebo cutoffs
for (i in vector) {
  print(paste("Cutoff at:", i))
  rdd <- rdrobust_fe_model(cc = i)
  #summary(rdd)
  rdd_placebo <- rdd_placebo %>%
    dplyr::add_row(
      placebo_c = i,
      point_estimate = rdd$coef[1],
      se = rdd$se[1],
      se_robust = rdd$se[3],
      ci_lower = rdd$ci[3,1],
      ci_upper = rdd$ci[3,2],
      p = rdd$pv[3],
      bw = rdd$bws[1,1],
      obs_below = rdd$N_h[1],
      obs_above = rdd$N_h[2]
  )
}
rdd_placebo <- rdd_placebo %>% drop_na()
rm(vector)
save(rdd_placebo, file = "tables_robustness_checks/rdd_placebo_2.Rdata")
```
```{r}
load(file = "tables_robustness_checks/rdd_placebo_2.Rdata")
rdd_placebo
```
Visualization of placebo cutoffs:
```{r, rdrobust_placebo_viz2}
df <- rdd_placebo %>%
  #tidyr::drop_na() %>%
  #filter(abs(ci_upper) < 100 | abs(ci_lower) < 100) %>%
  rowwise() %>%
  mutate(note = paste0("n=",
                       trimws(format(sum(obs_below, obs_above), big.mark = ",") ),
                       "\n",
                       p_value(p),
                       assign_stars(p) ) ) %>% # add big mark
  ungroup()
even_number <- round(abs(df$placebo_c*100) %% 2, 0) %% 2
ggplot2::ggplot(df) +
  geom_point(aes(x = placebo_c, y = point_estimate), size = 1.5, colour = ifelse(df$p <= 0.05, 2, 1)) +
  geom_errorbar(aes(x = placebo_c, ymin = ci_lower, ymax = ci_upper),
                colour = ifelse(df$p <= 0.05, 2, 1),
                linetype = ifelse(df$p <= 0.05, 2, 1),
                width = 0.015) +
  geom_text(aes(x = placebo_c,
                y = ifelse(even_number == 0, -0.8, -1),
                label = note),
            colour = ifelse(df$p <= 0.05, 2, 1),
            size = 2.7,
            vjust = 0) +
  geom_hline(aes(yintercept = 0), linetype = "dotted") +
  geom_vline(aes(xintercept = 0), linetype = "dotted") +
  scale_y_continuous(labels = scales::percent) +
  labs(x = "Cutoff of the running variable", y = y_lab_RDD)
ggsave(filename = "plots/rdrobust_placebo.pdf", width = 6, height = 6*9/16)
rm(df, even_number)
```

Third attempt: Random cutoffs within the inter-quartile range.

```{r, rdrobust_place3, eval=FALSE}
# to do: remove eval=FALSE
rdd_placebo <-
  tibble(placebo_c = "", point_estimate = "", se = "", se_robust = "",
         ci_lower = "", ci_upper = "", p = "", bw = "", obs_below = "", obs_above = "") %>%
  mutate(across(everything(), as.numeric))
set.seed(1234)
vector <- runif(n = 10, min = -0.15, max = 0.18) # Choose vector of random placebo cutoffs
for (i in vector) {
  print(paste("Cutoff at:", i))
  rdd <- rdrobust_fe_model(cc = i)
  #summary(rdd)
  rdd_placebo <- rdd_placebo %>%
    dplyr::add_row(
      placebo_c = i,
      point_estimate = rdd$coef[1],
      se = rdd$se[1],
      se_robust = rdd$se[3],
      ci_lower = rdd$ci[3,1],
      ci_upper = rdd$ci[3,2],
      p = rdd$pv[3],
      bw = rdd$bws[1,1],
      obs_below = rdd$N_h[1],
      obs_above = rdd$N_h[2]
  )
}
rdd_placebo <- rdd_placebo %>% drop_na() %>% arrange(placebo_c)
rm(vector)
save(rdd_placebo, file = "tables_robustness_checks/rdd_placebo_3.Rdata")
```
```{r}
load(file = "tables_robustness_checks/rdd_placebo_3.Rdata")
rdd_placebo
```
Visualization of placebo cutoffs:
```{r, rdrobust_placebo_viz3}
df <- rdd_placebo %>%
  #tidyr::drop_na() %>%
  #filter(abs(ci_upper) < 100 | abs(ci_lower) < 100) %>%
  mutate(effective_n = paste0("n=", trimws(format(sum(obs_below, obs_above), big.mark = ",") ) ) ) # add big mark
ggplot2::ggplot(df) +
  geom_point(aes(x = placebo_c, y = point_estimate), size = 1.5, colour = ifelse(df$p <= 0.05, 2, 1)) +
  geom_errorbar(aes(x = placebo_c, ymin = ci_lower, ymax = ci_upper),
                colour = ifelse(df$p <= 0.05, 2, 1),
                linetype = ifelse(df$p <= 0.05, 2, 1)) +
  geom_text(aes(x = placebo_c, y = ci_lower, label = effective_n),
            colour = ifelse(df$p <= 0.05, 2, 1), vjust = 1) +
  geom_hline(aes(yintercept = 0), linetype = "dotted") +
  geom_vline(aes(xintercept = 0), linetype = "dotted") +
  scale_y_continuous(labels = scales::percent) +
  labs(x = "Cutoff of the running variable", y = y_lab_RDD)
rm(df)
```

#### Sample split by `above_cutoff`

Based on main placebo "specification" ("second attempt", regular distances within inter-quartile range), I split the sample into two by values of the "instrument" `above_cutoff`:

```{r, rdrobust_placebo_split, eval=FALSE}
# to do: remove eval=FALSE
# Above
df <- d_rdd_bivariate %>% filter(above_cutoff == 1)
rdd_placebo_split <-
  tibble(sample = "", placebo_c = "", point_estimate = "", se = "", se_robust = "",
         ci_lower = "", ci_upper = "", p = "", bw = "", obs_below = "", obs_above = "") %>%
  mutate(across(2:last_col(), as.numeric))
vector <- seq(from = 0.015, to = (0.18), by = 0.015) # Choose vector of arbitrary placebo cutoffs
rdd_placebo_above <- rdd_placebo_split
for (i in vector) {
  print(paste("Cutoff at:", i))
  rdd <- rdrobust::rdrobust(
    y = df$ln_gross_expenditure_pc,
    x = df$inhabs_rel_to_cutoff,
    c = i,
    fuzzy = df$total_seats,
    cluster = df$inhabitants_treshold_factor,
    covs = model.matrix( ~ df$inhabitants_treshold_factor + df$year + df$state)
  )
  #summary(rdd)
  rdd_placebo_above <- rdd_placebo_above %>%
    dplyr::add_row(
      sample = "above",
      placebo_c = i,
      point_estimate = rdd$coef[1],
      se = rdd$se[1],
      se_robust = rdd$se[3],
      ci_lower = rdd$ci[3,1],
      ci_upper = rdd$ci[3,2],
      p = rdd$pv[3],
      bw = rdd$bws[1,1],
      obs_below = rdd$N_h[1],
      obs_above = rdd$N_h[2]
  )
}

# Below
df <- d_rdd_bivariate %>% filter(above_cutoff == 0)
vector <- seq(from = -0.18, to = -0.015, by = 0.015) # Choose vector of arbitrary placebo cutoffs
rdd_placebo_below <- rdd_placebo_split
for (i in vector) {
  print(paste("Cutoff at:", i))
  rdd <- rdrobust::rdrobust(
    y = df$ln_gross_expenditure_pc,
    x = df$inhabs_rel_to_cutoff,
    c = i,
    fuzzy = df$total_seats,
    cluster = df$inhabitants_treshold_factor,
    covs = model.matrix( ~ df$inhabitants_treshold_factor + df$year + df$state)
  )
  #summary(rdd)
  rdd_placebo_below <- rdd_placebo_below %>%
    dplyr::add_row(
      sample = "below",
      placebo_c = i,
      point_estimate = rdd$coef[1],
      se = rdd$se[1],
      se_robust = rdd$se[3],
      ci_lower = rdd$ci[3,1],
      ci_upper = rdd$ci[3,2],
      p = rdd$pv[3],
      bw = rdd$bws[1,1],
      obs_below = rdd$N_h[1],
      obs_above = rdd$N_h[2]
  )
}
# Bind
rdd_placebo_split <-
  rbind(rdd_placebo_above, rdd_placebo_below) %>%
  drop_na() %>%
  arrange(placebo_c)

# Save & clean up
rm(df, rdd_placebo_above, rdd_placebo_below, vector)
save(rdd_placebo_split, file = "tables_robustness_checks/rdd_placebo_split.Rdata")
```
```{r}
load(file = "tables_robustness_checks/rdd_placebo_split.Rdata")
rdd_placebo_split
```
Visualization of placebo cutoffs:
```{r, rdrobust_placebo_split_viz}
df <- rdd_placebo_split %>%
  filter(abs(ci_upper) < 15 | abs(ci_lower) < 15) %>%
  rowwise() %>%
  mutate(note = paste0("n=",
                       trimws(format(sum(obs_below, obs_above), big.mark = ",") ), # add big mark
                       "\n",
                       p_value(p),
                       assign_stars(p) ) ) %>%
  ungroup()
even_number <- round((df$placebo_c*1000), 0) %% 2
ggplot2::ggplot(df) +
  geom_point(aes(x = placebo_c, y = point_estimate), size = 1.5, colour = ifelse(df$p <= 0.05, 2, 1)) +
  geom_errorbar(aes(x = placebo_c, ymin = ci_lower, ymax = ci_upper),
                colour = ifelse(df$p <= 0.05, 2, 1),
                linetype = ifelse(df$p <= 0.05, 2, 1)) +
  geom_text(aes(x = placebo_c,
                y = ifelse(even_number == 0, -1.4, -1.8),
                label = note),
            colour = ifelse(df$p <= 0.05, 2, 1),
            size = 2.7,
            vjust = 0) +
  geom_hline(aes(yintercept = 0), linetype = "dotted") +
  geom_vline(aes(xintercept = 0), linetype = "dotted") +
  scale_y_continuous(labels = scales::percent) +
  labs(x = "Cutoff of the running variable", y = y_lab_RDD)
rm(df, even_number)
```


### Donut-hole RDD

#### Values of the running variable

```{r}
summary(d_rdd_bivariate$inhabs_rel_to_cutoff)
quantile(d_rdd_bivariate$inhabs_rel_to_cutoff, c(0.45, 0.55))
```


```{r}
#donut <- seq(0.005, 0.03, 0.005)
#donut <- seq(0.0025, 0.02, 0.0025)
donut <- seq(0.0025, 0.0325, 0.0025)
```
```{r, donut_rdd, eval=FALSE}
# to do: remove eval=FALSE
rdd_donut <-
  tibble(donut_radius = "", dropped_obs = "", point_estimate = "", se = "", se_robust = "",
         ci_lower = "", ci_upper = "", p = "",
         point_estimate_first_stage = "", ci_lower_first_stage = "", ci_upper_first_stage = "",
         bw = "", obs_below = "", obs_above = "") %>%
  mutate(across(everything(), as.numeric))
for (i in 1:length(donut)) {
  print(donut[i])
  print(paste("Number of dropped observations at the center:",
              d_rdd_bivariate %>% filter(abs(inhabs_rel_to_cutoff) <= donut[i]) %>% nrow(.)))
  df <- d_rdd_bivariate %>% filter(abs(inhabs_rel_to_cutoff) > donut[i])
  rdd <-
    rdrobust::rdrobust(
      y = df$ln_gross_expenditure_pc,
      x = df$inhabs_rel_to_cutoff,
      fuzzy = df$total_seats,
      cluster = df$inhabitants_treshold_factor,
      covs = model.matrix( ~ df$inhabitants_treshold_factor + df$year + df$state)
      )
  summary(rdd)
  rdd_donut <- rdd_donut %>%
    dplyr::add_row(
      donut_radius = donut[i],
      dropped_obs = d_rdd_bivariate %>% filter(abs(inhabs_rel_to_cutoff) <= donut[i]) %>% nrow(.),
      point_estimate = rdd$coef[1],
      se = rdd$se[1],
      se_robust = rdd$se[3],
      ci_lower = rdd$ci[3,1],
      ci_upper = rdd$ci[3,2],
      p = rdd$pv[3],
      point_estimate_first_stage = rdd$tau_T[1],
      ci_lower_first_stage = rdd$ci_T[3,1],
      ci_upper_first_stage = rdd$ci_T[3,2],
      bw = rdd$bws[1,1],
      obs_below = rdd$N_h[1],
      obs_above = rdd$N_h[2]
  )
  save(rdd, file = paste0("tables_robustness_checks/rdd_donut_rdrobust", i, ".RData"))
  df <- df %>% filter(closest <= 0.1)
  rdd <- fixest::feols(ln_gross_expenditure_pc ~
                         1  | # controls
                         inhabitants_treshold_factor + year + ags | # fixed-effect controls
                         # First stage regression:
                         inhabs_rel_to_cutoff*total_seats ~ # Instrument our standard RDD...
                         inhabs_rel_to_cutoff*above_cutoff, # ... with being above the cutoff
                       vcov = "threeway",
                       data = df)
  summary(rdd)
  save(rdd, file = paste0("tables_robustness_checks/rdd_donut_iv", i, ".RData"))
}
rdd_donut <- rdd_donut %>%
  drop_na() %>%
  mutate(share_dropped = dropped_obs / nrow(d_rdd_bivariate), .after = dropped_obs)
save(rdd_donut, file = "tables_robustness_checks/rdd_donut.Rdata")
rm(df)
```

```{r}
for (i in 1:length(donut)) {
  print(donut[i])
  print(paste("Number of dropped observations at the center:",
              d_rdd_bivariate %>% filter(abs(inhabs_rel_to_cutoff) <= donut[i]) %>% nrow(.)))
  df <- d_rdd_bivariate %>% filter(abs(inhabs_rel_to_cutoff) > donut[i])
  load(file = paste0("tables_robustness_checks/rdd_donut_rdrobust", i, ".RData"))
  #summary(rdd)
  load(file = paste0("tables_robustness_checks/rdd_donut_iv", i, ".RData"))
  #summary(rdd)
}
load(file = "tables_robustness_checks/rdd_donut.Rdata")
rdd_donut
```
```{r}
rm(donut)
```

```{r}
text_size <- 2.75
df <- rdd_donut %>%
  filter(donut_radius <= 0.025) %>%
  mutate(donut_radius = paste0("[-", donut_radius, ",", donut_radius, "]")) %>%
  rowwise() %>%
  mutate(note = paste0("n=",
                       trimws(format(sum(obs_below, obs_above), big.mark = ",") ) # add big mark
                       ),
         note2 = paste0(p_value(p), assign_stars(p))) %>%
  ungroup()
ggplot2::ggplot(data = df, aes(x = donut_radius, y = point_estimate)) +
  geom_point(size = 1.5, color = ifelse(df$p <= 0.05, 2, 1)) +
  geom_errorbar(aes(ymin = ci_lower, ymax = ci_upper),
                color = ifelse(df$p <= 0.05, 2, 1),
                linetype = ifelse(df$p <= 0.05, 2, 1),
                width = 0.25) +
  geom_text(aes(x = donut_radius, y = -0.025, label = note),
            colour = ifelse(df$p <= 0.05, 2, 1), size = text_size,
            vjust = 0) +
  annotate(geom = "text", x = df$donut_radius, y = -0.03166667,
           label = latex2exp::TeX("$n_{dropped}$="),
            colour = ifelse(df$p <= 0.05, 2, 1), size = text_size,
           vjust = 0) +# Doesn't work with geom_text, apparently
  geom_text(aes(x = donut_radius, y = -0.03833333,
                label = format(dropped_obs, big.mark = ",")),
            colour = ifelse(df$p <= 0.05, 2, 1), size = text_size,
            vjust = 0) +
  geom_text(aes(x = donut_radius, y = -0.045, label = note2),
            colour = ifelse(df$p <= 0.05, 2, 1), size = text_size,
            vjust = 0) +
  geom_hline(aes(yintercept = 0), linetype = "dotted") +
  scale_y_continuous(labels = scales::percent) +
  labs(x = "Interval of excluded data of the running variable (population relative to thresholds)",
       y = y_lab_RDD) +
  theme(axis.text.x = element_text(size = 6))
ggsave(filename = "plots/rdd_donut.pdf", width = 7, height = 7*9/16)
rm(df, text_size)
```

Plotting only "donuts" close to the threshold (i. e. running variable $|X| \leq 0.025$) as this would be where sorting would most likely occur.

Seven out of ten regressions are positively significant...

#### (Percentage) windows of the running variable

```{r}
donut_window <- seq(0.01, 0.09, 0.01)
```
```{r, donut_window_rdd, eval=FALSE}
# to do: remove eval=FALSE
rdd_donut_window <-
  tibble(donut_window = "", dropped_obs = "", point_estimate = "", se = "", se_robust = "",
         ci_lower = "", ci_upper = "", p = "",
         point_estimate_first_stage = "", ci_lower_first_stage = "", ci_upper_first_stage = "",
         bw = "", obs_below = "", obs_above = "") %>%
  mutate(across(everything(), as.numeric))
for (i in 1:length(donut_window)) {
  print(donut_window[i])
  print(paste("Number of dropped observations at the center:",
              d_rdd_bivariate %>% filter(closest <= donut_window[i]) %>% nrow(.)))
  df <- d_rdd_bivariate %>% filter(closest > donut_window[i])
  rdd <-
    rdrobust::rdrobust(
      y = df$ln_gross_expenditure_pc,
      x = df$inhabs_rel_to_cutoff,
      fuzzy = df$total_seats,
      cluster = df$inhabitants_treshold_factor,
      covs = model.matrix( ~ df$inhabitants_treshold_factor + df$year + df$state)
      )
  summary(rdd)
  do <- d_rdd_bivariate %>% filter(closest <= donut_window[i]) %>% nrow(.)
  rdd_donut_window <- rdd_donut_window %>%
    dplyr::add_row(
      donut_window = donut_window[i],
      dropped_obs = do,
      point_estimate = rdd$coef[1],
      se = rdd$se[1],
      se_robust = rdd$se[3],
      ci_lower = rdd$ci[3,1],
      ci_upper = rdd$ci[3,2],
      p = rdd$pv[3],
      point_estimate_first_stage = rdd$tau_T[1],
      ci_lower_first_stage = rdd$ci_T[3,1],
      ci_upper_first_stage = rdd$ci_T[3,2],
      bw = rdd$bws[1,1],
      obs_below = rdd$N_h[1],
      obs_above = rdd$N_h[2]
  )
  save(rdd, file = paste0("tables_robustness_checks/rdd_donut_window_rdrobust", i, ".RData"))
  df <- df %>% filter(closest <= 0.1)
  rdd <- fixest::feols(ln_gross_expenditure_pc ~
                         1  | # controls
                         inhabitants_treshold_factor + year + ags | # fixed-effect controls
                         # First stage regression:
                         inhabs_rel_to_cutoff*total_seats ~ # Instrument our standard RDD...
                         inhabs_rel_to_cutoff*above_cutoff, # ... with being above the cutoff
                       vcov = "threeway",
                       data = df)
  summary(rdd)
  save(rdd, file = paste0("tables_robustness_checks/rdd_donut_window_iv", i, ".RData"))
}
rdd_donut_window <- rdd_donut_window %>%
  drop_na() %>%
  mutate(share_dropped = dropped_obs / nrow(d_rdd_bivariate), .after = dropped_obs)
save(rdd_donut_window, file = "tables_robustness_checks/rdd_donut_window.Rdata")
rm(df, do)
```

```{r}
for (i in 1:length(donut_window)) {
  print(donut_window[i])
  print(paste("Number of dropped observations at the center:",
              d_rdd_bivariate %>% filter(closest <= donut_window[i]) %>% nrow(.)))
  df <- d_rdd_bivariate %>% filter(closest > donut_window[i])
  load(file = paste0("tables_robustness_checks/rdd_donut_window_rdrobust", i, ".RData"))
  #summary(rdd)
  load(file = paste0("tables_robustness_checks/rdd_donut_window_iv", i, ".RData"))
  #summary(rdd)
}
load(file = "tables_robustness_checks/rdd_donut_window.Rdata")
rdd_donut_window
```
```{r}
rm(donut_window)
```

```{r}
text_size <- 2.75
df <- rdd_donut_window %>%
  #filter(donut_window <= 0.025) %>%
  #mutate(donut_radius = paste0("[-", donut_radius, ",", donut_radius, "]")) %>%
  rowwise() %>%
  mutate(note = paste0("n=",
                       trimws(format(sum(obs_below, obs_above), big.mark = ",") ) # add big mark
                       ),
         note2 = paste0(p_value(p), assign_stars(p))) %>%
  ungroup()
ggplot2::ggplot(data = df, aes(x = donut_window, y = point_estimate)) +
  geom_point(size = 1.5, color = ifelse(df$p <= 0.05, 2, 1)) +
  geom_errorbar(aes(ymin = ci_lower, ymax = ci_upper),
                color = ifelse(df$p <= 0.05, 2, 1),
                linetype = ifelse(df$p <= 0.05, 2, 1),
                width = 0.002) +
  geom_text(aes(x = donut_window, y = -0.03, label = note),
            colour = ifelse(df$p <= 0.05, 2, 1), size = text_size,
            vjust = 0) +
  annotate(geom = "text", x = df$donut_window, y = -0.03666667,
           label = latex2exp::TeX("$n_{dropped}$="),
            colour = ifelse(df$p <= 0.05, 2, 1), size = text_size,
           vjust = 0) +# Doesn't work with geom_text, apparently
  geom_text(aes(x = donut_window, y = -0.04333333,
                label = format(dropped_obs, big.mark = ",")),
            colour = ifelse(df$p <= 0.05, 2, 1), size = text_size,
            vjust = 0) +
  geom_text(aes(x = donut_window, y = -0.05, label = note2),
            colour = ifelse(df$p <= 0.05, 2, 1), size = text_size,
            vjust = 0) +
  geom_hline(aes(yintercept = 0), linetype = "dotted") +
  scale_x_continuous(labels = scales::percent) +
  scale_y_continuous(labels = scales::percent) +
  labs(x = "Window around the threshold",
       y = y_lab_RDD)
ggsave(filename = "plots/rdd_donut_window.pdf", width = 7, height = 7*9/16)
rm(df, text_size)
```


### Mass points

Investigating and counting mass points:

```{r}
sum(!is.na(data$inhabs_rel_to_cutoff)) # Number of valid observations of running variable
length(unique(data$inhabs_rel_to_cutoff)) # Number of unique values of running variable
sum(!is.na(data$inhabs_rel_to_cutoff)) / length(unique(data$inhabs_rel_to_cutoff)) # 18 observations per value
```

#### Clustering at discrete values

Lee and Card (2008) procedure: Clustering at the respective dicrete values of the running variable. As for as I know, this is only possible in the IV approach. However, it has been shown not to be a statistically valid approach (see next subsection).

```{r}
rdd <-
  rdrobust::rdrobust(
    y = d_rdd_bivariate$ln_gross_expenditure_pc,
    x = d_rdd_bivariate$inhabs_rel_to_cutoff,
    fuzzy = d_rdd_bivariate$total_seats,
    cluster = d_rdd_bivariate$inhabs_rel_to_cutoff,
    covs = model.matrix( ~ d_rdd_bivariate$inhabitants_treshold_factor + d_rdd_bivariate$year + d_rdd_bivariate$state)
  )
summary(rdd)
```
```{r}
df <- d_rdd_bivariate %>%
  filter(closest <= 0.1) # Choose bandwidth window -- similar to Höhmann (2017)
# only one FE
rdd <- fixest::feols(
  ln_gross_expenditure_pc ~
    1  | # controls
    inhabitants_treshold_factor | # fixed-effect controls
    # First stage regression:
    inhabs_rel_to_cutoff * total_seats ~ # Instrument our standard RDD...
    inhabs_rel_to_cutoff * above_cutoff, # ... with being above the cutoff
  cluster = c("inhabitants_treshold_factor", "inhabs_rel_to_cutoff"),
  data = df
)
summary(rdd)
# three FE
rdd <- fixest::feols(
  ln_gross_expenditure_pc ~
    1  | # controls
    inhabitants_treshold_factor + year + ags | # fixed-effect controls
    # First stage regression:
    inhabs_rel_to_cutoff * total_seats ~ # Instrument our standard RDD...
    inhabs_rel_to_cutoff * above_cutoff, # ... with being above the cutoff
  cluster = c("inhabitants_treshold_factor", "year", "ags", "inhabs_rel_to_cutoff"),
  data = df
)
summary(rdd)
rm(df, rdd)
```

IV approach does not alter the conclusions significantly but the `rdrobust` one does... Note that this approach is not statistically sound (see next subsection and its paper).


#### `RDHonest` package

Based on Kolesár & Rothe (2018):

```{r}
# Sharp (intention to treat)
RDHonest::RDHonest(
  formula = ln_gross_expenditure_pc ~ inhabs_rel_to_cutoff,
  data = d_rdd_bivariate#,
  #clusterid = model.matrix( ~  inhabitants_treshold_factor) # No idea how to correctly specify the clusterid variable
)
# Fuzzy
# RDHonest::RDHonest(
#   formula = ln_gross_expenditure_pc ~ inhabs_rel_to_cutoff + total_seats,
#   data = d_rdd_bivariate
# )
```

The results from the sharp `RDHonest` are interesting in that the parameter is significant. However, the estimation is not clustered at the respective thresholds, presumable invalidating the result.

For the fuzzy case, I do not know how to run it. According to the [`RDhonest` vignette](https://github.com/kolesarm/RDHonest/blob/master/vignettes/RDHonest.Rmd), one needs a function called `FRDData`, which is, however, apparently not part of the package.


# Concluding Remarks

For references, see the paper.

```{r}
Sys.time() - time
```
